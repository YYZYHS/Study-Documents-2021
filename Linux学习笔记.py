第一章  操作系统发展及linux介绍
    ➢操作系统演变及历史介绍
        ----操作系统的目标
            --->方便:使计算机系统易于使用
            --->有效:以更有效的方式使用计算机系统资源
            --->扩展:方便用户有效开发、测试和引进新功能
        ----操作系统的功用
            --->进程管理
            --->内存管理
            --->文件系统
            --->设备控制
            --->网络管理
        ----操作系统在计算机系统中承上下的地位
            --->向下封装硬件
            --->向上提供操作接口
            --->详见图片:E:\学习笔记\其他资料\Linux\Image\操作系统的功能.jpg
        ----操作系统的发展经历
            --->无操作系统阶段(1946-1976)
                --->从1946年诞生第一台电子计算机以来,最初的电脑并没有操作系统,人们通过各种按钮来控制计算机
                --->后来出现了汇编语言,操作人员通过有孔的纸带将程序输入电脑进行编译
                --->这些将语言内置的电脑只能由操作人员自己编写程序来运行,不利于设备、程序的共用
            --->简单8位、16位操作系统阶段————单任务、单用户操作系统(CP/MDOS)(1974-1990)
                --->随着计算技术和大规模集成电路的发展,微型计算机迅速发展起来
                --->最早的操作系统(CP/M):8位
                    -->1974年:美国 RESEARCH软件公司研制
                --->操作系统的第一次飞跃: MS-DOS 16位
                    -->1980年:微软从一个黑客那里买到了dos操作系统的源码与使用权,开始了一个新的时代
                --->1980年-90年初:世界进入了长达10年dos黑屏时代
                    -->DOS系统的单用户、单任务、字符界面和16位的大格局没有变化
            --->复杂的多任务、多用户操作系统阶段(WINDOWS/UNIX/MAC)
                --->第一款32位视窗系统:(OS/2)
                    -->IBM和 Microsoft共同研制的一种个人操作系统
                    -->后来因为各种原因, Microsoft转向windows视窗
                    -->IBM单独完成的一款图形化操作系统视窗家族
                --->Windows视窗系统
                    -->从微软1985年推出Windows 1.0以来, Windows系统从最初运行在DOS下的Windows 3.x
                    -->到现在风靡全球的 Windows9x/Me/2000/NT/XP,几乎成为了操作系统的代名词
                    -->是目前市场占有率最高的个人操作系统
            --->主流操作系统(32位/64位)(1990-现在)
                --->PC: windows家族、unix家族、mac家族
                    -->Microsoft Windows:主要用于个人桌面
                        ➢1985: windows 1.x
                        ➢1987: windows 2.x
                        ➢1990: windows 3.x
                        ➢1995: windows 95
                        ➢1998: windows 98
                        ➢2000: windows 2000
                        ➢2002: windows xp
                        ➢2006: windows vista
                        ➢2007: windows 7
                        ➢2012: windows 8
                    -->UNIX系统:主要应用于服务器
                        ➢Unix起源:
                            ||麻省理工学院、贝尔实验室、通用电气合作项目-Multics
                            ||后来因为项目太为复杂失败
                        ➢1969:
                            ||其主要开发者Thompson和Ritchie领导一组开发者，开发了一个新的多任务操作系统----UNICS
                            ||后来被改名为unix，最初的Unix是用B语言和汇编语言混合编写的
                        ➢1971:
                            ||Thompson和Ritchie在贝尔实验室共同发明了C语言
                        ➢1973
                            ||Thompson和Ritchie用C语言重写了Unix
                        ➢1974年
                            ||UNIX第一次出现在贝尔实验室以外。
                            ||此后UNIX被政府机关，研究机构，企业和大学注意到，并逐渐流行开来
                        ➢1975-1979
                        UNIX发布了4、5、6、7三个开源版本
                        ➢1982年
                            ||AT&T基于版本7开发了UNIX System的第一个商业版本,并不再开源
                        ➢UNX的一个重要分支:BSD
                            ||美国加州大学继续开发开源的UNIX-BSD
                            ||变种BSD Unix在Unix的历史发展中具有相当大的影响力,被很多商业厂家采用
                        ➢BSD的一场灾难:
                            ||由于版权问题,AT&T公司与BSD开发组开始了一场将近10年的版权官司(1992^2001.9)
                            ||UNIX由于其昂贵的费用,仅局限于大型机的应用
                            ||BSD因为版权问题,失去了宝贵的发展时期
                    -->Linux系统:免费、跨平台,未来的主流
                        ➢Linux的父亲: miniX
                        ➢MiniX最初是由Andrew Tanenbaum教授,仿照4.3BSD的源代码,白手起家完成了12000行C语言的编写工作
                            ||这个系统只是一个教学工具,没有什么实际应用价值
                        ➢1990年, Linus Torvalds决定编写一个自己的MiniX内核
                            ||初名为 Linus’ MiniX,意为Linus的MiniX内核
                            ||后来改名为Linux,此内核于1991年正式发布,并逐渐引起人们的注意
                        ➢Radhat:
                            ||fedora/redhat/Enterprise/Centos/redflag
                        ➢openSUSE
                        ➢Ubuntu:
                            ||Debian Kubuntu Xubuntu Linux Mint
                        ➢Gentoo Linux
                        ➢FreeBSD
                        ➢Puppy Linux
                        ➢Android
                        ➢MeeGo:
                            ||Moblin/LiMo
                    -->Apple MAC系统:专注于图形图像处理与制作
                --->嵌入式: ucosII、 linux、 winCE、 android、iOS等
                    -->iOS:由苹果公司开发的手持设备操作系统
                    -->android: google2007年推出,各大厂商顶力支持
                    -->windowsMobile: microsoft针对移动市场推出的
                    -->symbian、 MeGoo、 blackberry、bada
        ----Linux的用户分两类
            --->一类是知道自己在用Linux的
                ||就是直接使用Linux系统的人
            --->一类是不知道自己在用Linux的
                ||Android的内核时Linux
                ||MeeGo的内核也是Linux
            --->还有第三类是Unix家族的远亲
                ||ios <-- Darwin <-- BSD <-- UNIX
    ➢Linux操作系统介绍
        ----Linux是最受欢迎的自由电脑操作系统内核
            --->是一个用C语言写成,符合POSIX标准的类Unix操作系统
        ----诞生于199年10月5日
            --->由芬兰黑客Linus Torvalds为尝试在英特尔x86架构上提供自由免费的类Unix操作系统而开发的
        ----Linux操作系统的诞生、发展、和成长过程依赖于五个重要支柱
            --->unⅸ操作系统
            --->miniⅸ操作系统
            --->GNU计划
            --->POSⅨ标准
            --->互联网
        ----unix操作系统/mIniX操作系统
            --->linux操作系统的前身
            --->是 linux一直模仿和要超越的对象
        ----GUN计划和自由软件基金会(FSF):
            --->Richard M. Stallman于1984年创办,旨在开发一个免费、类unix的操作系统-GNU系统及其开发工具
            --->Emacs编辑系统、 BASH shell程序、GC、GDB等开发工具都是GNU组织的产品
            --->后来与1imux内核结合成为了现在的GNU/1inux
            --->FSF:于1985年10月建立,监督保证执行GNU计划
        ----POSIX ( Portable Operating System Interface)
            --->可移植操作系统接口,由电气和电子工程师协会(IEEE) 开发用来统一unix、 linux各分支编程接口，以提高其通用型和可移植性
            --->使得linux的发展结束了初期的混乱发展阶段,进入了一个新的时期
        ----互联网
            --->来自世界各地的黑客、自由软件推崇者通过网络联合在一起,完成了linux的开发工作
        ---- Richard Stallman
            --->天才程序员
            --->主持了著名的GNU工程
            --->GNU的定义: GNUs Not unix
            --->自由软件基金会:
                -->Free Software Foundation(FSF)
            --->Richard stallman两款自由软件: Emacs、gcc
            --->General Public License (GPL)
            --->GNU工程与 Linux
    ➢Linux内核及发行版介绍
        ----Linux内核版本:稳定版和开发版
            --->稳定版内核具有工业级的强度,可以广泛地应用和部署。
            --->新的稳定内核相对于较旧的只是修正一些bug或加入一些新的驱动程序。
            --->而开发版内核由于要试验各种解决方案,所以变化很快。
            --->这两种版本是相互关联,相互循环的。
        ----Linux内核版本号由3个数字组成(3.0以后已不用)
            --->major. minor. patch[.des] 
            --->major:表示主版本号,有结构性变化时才变更。
            --->minor:表示次版本号,新增功能时才发生变化。
                -->一般奇数表示测试版,偶数表示生产版。
            --->patch:错误修补的次数。
            --->des:微调的次数,一般稳定版本仅有前三个数字。
        ----Linux发行版
            --->也被叫做GNU/ Linux发行版
                -->通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。
            --->这些操作系统通常由 Linux内核、以及来自GNU计划的大量的函数库,和基于X Window的图形界面。
            --->有些发行版考虑到容量大小而没有预装X Window而使用更加轻量级的软件
                -->如: busybox,uclibc或 dietlibc
            --->现在有超过300个Linux发行版(Linux发行版列表)
        ----这些发行版可以分为:
            --->商业发行版
                -->Fedora(Red Hat)
                -->openSUSE (Novell)
                -->Ubuntu(Canonical公司)
                -->Mandriva Linux
            --->社区发行版:
                -->它们由自由软件社区提供支持
                -->DebianGentoo
                -->Gentoo
            --->也有发行版既不是商业发行版也不是社区发行版
                -->其中最有名的是 Slackware
                -->他由 atrick Volkerding发行维护
    ➢Linux开发应用领域介绍
        ----个人桌面领域的应用
            --->此领域是传统 linux应用最薄弱的环节
            --->但近些年来随着ubuntu、fedora等优秀桌面环境的兴起
            --->同时各大硬件厂商对其支持的加大,Linux在个人桌面领域的占有率在逐渐的提高
            --->典型代表: ubuntu、 fedora、 suse linux
        ----服务器领域
            --->linux在服务器领域的应用是其重要分支
            --->linux免费、稳定、高效等特点在这里得到了很好的体现
            --->但早期因为维护、运行等原因同样受到了很大的限制
            --->但近些年来 linux服务器市场得到了飞速的提升,尤其在一些高端领域尤为广泛
            --->典型代表:
                -->Red Hat公司的AS系列
                -->完全开源的 debian系列
                -->suse EnterPrise11系列等
        ----嵌入式领域
            --->近些年来 linux在嵌入式领域的应用得到了飞速的提高
            --->linux运行稳定、对网络的良好支持性、低成本,且可以根据需要进行软件裁剪,内核最小可以达到几百KB等特点,使其近些年来在嵌入式领域的应用得到非常大的提高
            --->主要应用:机顶盒、数字电视、网络电话、程控交换机、手机、PDA、等都是其应用领域
            --->得到了摩托罗拉、三星、NEC、 Google等公司的大力推广
第二章  Linux开发环境搭建— ubuntu
    ➢系统安装方案
        ----光驱安装
        ----USB安装
        ----使用镜像从硬盘安装
        ----服务器安装
            --->优点
                -->最大化利用了局域网内的公共资源,不占用自己的资源,便于数据备份与交换。
            --->缺点
                -->对linux的感受不是十分形象,在调试某些程序,如网络、硬件等会造成资源冲突。
        ----虚拟机安装
            --->优点
                -->由虚拟机软件虚拟出一台或多台电脑
                -->从而在一台机器上同时运行二个或更多的操作系统,并进行数据交换,方便快捷。
                -->使用Linux的同时,还可借助于 windows下的一些工具及网络资源进行学习。
            --->缺点
                -->虚拟出的电脑的性能相比物理机较差,很多效果无法实现,如ubuntu的3D效果
                -->它对物理机的性能,如内存、CPU、磁盘等要求较高。
    ➢安装系统(虚拟机安装)
        ----虚拟机介绍
            --->虚拟机可以说是一种软件,也可以说是一种技术,
            --->它允许你在一台主机上虚拟出多台计算机,每台虚拟的计算机都可以有自己的硬件及软件配置。
        虚拟机技术的作用
            --->可以帮助网络架构工程师在一台电脑上模拟检测整个网络运行情况。
            --->可以极大的降低企业的运营成本与风险。
            --->可以帮助操作系统设计者测试、解决问题。
            --->可以帮助开发者在多个平台上进行自由切换
        ----三种虚拟机软件
            --->Virtual PC
                -->是Microsoft公司开发的一个免费的“虚拟机”软件
                -->它使用户可以在一台机器上同时运行多个操作系统
            --->VMware
                -->是目前市场占有率最高的虚拟机
                -->是虚拟界巨头VMware公司的产品,其功能非常强大且稳定
            --->VirtualBox
                -->是德国一家软件公司Innotek所开发的虚拟系统软件
                -->它不仅具有丰富的特色,而且性能也很优异,更是开源的
                -->成为了一个发布在GPL许可之下的自由软件,现在由甲骨文公司进行开发
    ➢ubuntu的使用
        ----vmtools
            --->介绍
                -->vmtools是Vmware的工具包
                -->对Vmware中安装的linux起到增强的效果,但是对物理机安装的Linux不起作用。
            --->vmtools的作用:
                -->用于虚拟机显示的优化与调整。
                -->允许共享主机文件夹,方便虚拟机访问主机文件
                -->可以直接使用右键复制 windows字符串到linux编辑器或终端。
            --->vmtools的安装
                -->略。。。
        ----软件包管理
            --->ubuntu更新设置
                -->说明
                    ||ubuntu操作系统发布时,为了减小操作系统的体积,仅仅配备了基本的系统软件、应用软件
                    ||我们开发中需要用到的大部分软件都需要在使用中从网上自行更新
                -->方法
                    ||可以上网的虚拟机,直接可从互联网更新软件。
                    ||ubuntu默认的更新源速度不是很快,我们可以改为163或sohu提供的更新源。
                    ||新版本有选择最佳服务器的选项，也可使用这个
                -->开始更新
                    ||设置好局域网更新源后,我们可以使用图形界面或者字符界面更新系统及应用程序。
                        ->图形界面 ---> 使用"更新管理器"
                        ->字符界面
                            >sudo apt-get- update//获得最新的软件包的列表
                                Δ、在设好更新源后,必须先执行此命令。
                            >sudo apt-get- install xxx//从源中安装xxx软件
                            >sudo apt-get- remove xxx//删除包
                            >sudo apt-get- download xxx//从源中下载 xxx deb包 ---> 已编译
                            >sudo apt-get- source xxx//从源中下载xx的源码包 ---> 未编译
                            >sudo apt-get- upgrade//更新系统文件
                                Δ、更新时提示:无法获得锁/var/lib/...
                                Δ、sudo rm /var/cache/apt/archives/lock
                                Δ、sudo rm /ver/lib/dpkg/lock
    ➢安装必备软件-ubuntu
        ----samba
            --->简介
                -->samba服务器在两种不同的操作系统间架起了一座桥梁,使Linux系统和Windows系统之间能够通信。
                -->Linux操作系统下的samba服务,实现了Windows主机访问Linux下共享文件的功能。
                -->为广泛的 Linux爱好者提供了极大方便。
            --->ubuntu下安装samba
                -->安装命令:
                    ->sudo apt-get install samba cifs-utils smbclient system-config-samba
                -->注:
                    ->samba: samba核心组件。
                    ->smbfs:支持SMB/CIFS协议的文件系统。
                        ||安装时，出现了新的问题
                            //没有可用的软件包 smbfs，但是它被其它的软件包引用了。
                            //这可能意味着这个缺失的软件包可能已被废弃，
                            //或者只能在其他发布源中找到
                            //然而下列软件包会取代它:
                            //  cifs-utils cifs-utils:i386
                            //
                            //果断选择替换安装cifs-utils
                                --sudo apt-get install cifs-utils
                    ->smbclient: samba客户端,访问其它机器。
                    ->system-config-samba:图形界面配置工具
                        //实操记录
                            ||安装完成后，出现samba快捷方式没有出现在开始菜单中
                            ||通过终端调用:sudo system-config-samba
                                ##第一次运行时，系统提示少了一个文件
                                ##使用touch指令将创建那个文件，然后视图窗口配置工具就可以正常运行了
            ----使用
                --->图形界面
                    -->step1:添加用户
                    ->|首选项 --> samba用户 --> 添加用户 --> 填写信息
                        -> Windows用户名:windows访问Linux时需要的用户名
                        ->Samba密码:windows访问Linux时需要的密码
                    -->step2:设置Linux共享目录
                        ->绿色加号"+"  --> 填写信息 --> 选择可访问对象
                --->字符界面
                    -->1、添加用户:
                        ->sudo smbpasswd-a账号
                        ->增加 samba账号和密码
                        ->账号必须为已经存在的 linux用户
                    -->2、设置 Linux共享目录及其权限:
                        ->文件/etc/samba/smb.conf决定samba的共享目录及权限。
                        ->修改方法:sudo gedit /etc/samba/smb. conf
                            Δ、/etc/ samba/smb.conf修改方法
                                //登录时需要用户名、密码验证
                                    || [edu]            #共享名称
                                    ||comment = *       #设置共享的备注
                                    ||path=/home/edu    #共享文件夹路径
                                    ||valid users=edu   #windows的用户登陆名
                                    ||writeable yes     #是否可写
                                    ||browseableyes     #是否可显示
                                //登录时不需要用户名、密码验证
                                    || [edu]            #共享名称
                                    ||comment = *       #设置共享的备注
                                    ||path=/home/edu    #共享文件夹路径
                                    ||writeable yes     #是否可写
                                    ||browseable=yes    #是否可显示
                                    ||guest ok yes
                    -->3、重启samba服务器:
                        ->方法一: sudo restart smbd
                        ->方法二: sudo service smbd restart
                        ->方法三:sudo/etc/init.d/smbd restart
                        ->在重启其它服务时类似地把smbd替换成别的服务器名即可(如ssh)。
                    -->4、删除用户:
                        ->sudo smbpasswd -x 账号
        ----ssh
            --->简介
                -->ssh为 Secure shell的缩写
                -->它由互联网工程仼务组(IETF-The Internet Engineering TaskForce)的网络工作小组( Network Working Group)所制定。
                -->ssh是建立在应用层和传输层基础之上的安全协议。
                -->ssh是目前较可靠,专为远程登录会话和其他网络服务提供安全性的协议。
            --->ubuntu安装ssh服务器:
                -->sudo apt-get install openssh-server
            --->重启ssh服务(必要时使用):
                -->sudo /etc/init. d/ssh resart
    ➢安装必备软件-windows
        ----Xshell
第三章  Linux下编程工具(概述、目录结构)
    ➢Linux 环境开发概述
        ----windows开发方式特点
            --->在电脑上装一个vc或其它"集成开发环境"(IDE)
            --->编辑程序->编译程序->看现象->有问题->修改程序->调试程序->查看
        ----Linux开发特点:
            --->Linux下的程序开发大多通过在本地安装虚拟机物理机或网络连接到服务器完成
            --->出于效率、远程开发、嵌入式开发的考虑:开发方式大多是在命令行下完成,没有很好的集成开发环境供我们使用
        ----Linux文件及目录结构:
            --->无论何种版本的Linux,桌面、应用是 Linux的外衣
            --->文件组织、目录结构才是Linux的内心
        ----Linux命令
            --->无命令,不 Linux
        ----编辑器、编译器、调试器:
            --->写程序永远离不开:编辑、编译、调试
            --->不同 windows下完善集成开发环境, Linux下以上操作大多在字符界面通过各种各样命令完成,品尝自己原始加工的乐趣
        ----shell脚本+ makefile
            --->shell脚本处理Linux中复杂而又繁琐的操作
            --->makefile管理复杂的代码关系
    ➢Linux 文件及目录结构
        ----简述
            --->操作系统需要安装在特定的硬件系统中才能发挥作用
            --->Linux也不例外,Linux可以安装在
                -->硬盘(个人PC、服务器)上
                -->FLASH(嵌入式设备)上
                -->U盘、光盘、移动硬盘等移动设备上
            --->无论安装在何种介质上,其最终展现在用户面前的操作方式都是一样的
            --->以上灵活的部署方式,离不开其架构上设计的特点:
                -->大树底下好乘凉:对磁盘分区的管理(树状)
                -->一切皆文件:对数据、硬件设备的管理
            --->大树底下好乘凉:Linux采用树状结构管理磁盘
                -->Linux系统构建一个叫做根文件系统的东西
                    ->其实就是一堆文件夹、文件的集合
                    ->里面存放着Linux启动必需的一些配置文件、库文件、应用程序
                -->根文件系统按照一定格式存放在硬盘、FLASH中的某一个分区
                    ->Linux内核启动起来后首先会启动它
                -->其他分区、U盘、SD卡、光盘等"挂载"在根文件系统的某一目录下
                    ->我们通过此目录访问此此磁盘
                -->总之:
                    ->Linux中我们看不到类似于Windows下的C、D、E盘
                    ->我们看到就是一棵大树
            --->一切皆文件:对数据、硬件设备的管理
                -->Linux对磁盘的管理抽象为文件夹(前面提到的树)
                -->Linux对:
                    ->数据文件(mp3、bmp)
                    ->程序文件(.c、.)
                    ->设备文件(LCD、触摸屏、鼠标)
                    ->网络文件(socket)
                    ->等的管理都抽象为文件,使用统一的方式方法管理
                -->总之:
                    ->文件在Linux下赋予了崭新的含义和地位
        ----Linux目录结构
            --->发展历史
                -->在早期的UNIX系统中,各个厂家各自定义了自己的UNIX系统文件目录,比较混乱。
                -->在Linux面世不久,就对Linux文件目录进行标准化的活动
                -->于1994年对根文件目录做了统一的规范,推出了名为FHS(Filesystem Hierarchy Standard)的Linux文件系统层次结构标准。
                -->FHS标准规定了Linux根目录各文件夹的名称及作用,统一了Linux界命名混乱的局面。
            --->"/"(根目录)是Linux系统中最顶层的目录，所有的文件夹、文件都是它的子目录。
                -->详见图片:E:\学习笔记\其他资料\Linux\Image\Linux目录结构.jpg
            --->Linux采用树状结构管理所有目录、文件
                -->先构建顶层根目录，再将硬盘的不同分区挂载到不同的目录下。
                    ->这些目录被称为挂载点或安装点，然后通过此目录来访问这个分区上的文件。
                -->Linux引导启动时，默认使用根目录
                    ->其中一般都包括这样一些子目录:bin、sbin、usr、 boot、var、etc等。
                -->不同的外表下总有一颗相同的心
                    ->无论何种版本的Linux发行版，桌面、应用是Linux的外衣
                    ->文件组织、目录结构才是Linux的内心
            --->目录名称及功能
                --> / (根目录)
                    ->在Linux下有且只有一个根目录
                    ->所有的东西都是从这里开始
                    ->当你在终端里输入“/home”，你其实是在告诉电脑，先从/(根目录)开始，再进入到home目录。
                --> /home
                    ->每个用户都有自己的用户目录:/home/用户名用来存放用户的数据、设置文件等。
                --> /root
                    ->这是系统管理员(root user)的目录
                --> /bin
                    ->这里存放了标准的linux的工具，比如像“ls”、 “cat”、“mv”、“cp”等。
                --> /sbin
                    ->存放涉及系统管理的命令，只有系统管理员才可执行，普通用户无权限执行这个目录下的命令。
                    ->在系统其它目录下的sbin目录下包含的都是root权限才能执行的命令。
                --> /lib
                    ->主要用于存放应用程序所需的共享库，在Linux执行或编译一些程序的时候，用到的一些库，就在这个目录下
                --> /etc
                    ->这里存放了系统、软件的配置文件。
                    ->如用户的账号与密码、系统的主要设定、所要开启的服务项目。
                    -> 例:你安装了samba这个套件，当你想要修改samba配置文件的时候，你会发现samba配置文件就在 /etc/samba目录下。
                --> /boot
                    ->放置linux系统启动时相关的文件。
                    -> 如:
                        ||linux的内核文件:/boot/vmlinuz
                        ||系统引导管理器:/boot/grub
                --> /var
                    ->系统执行过程中经常变化的文件
                    ->如:
                        ||/var/log:随时更改的日志文件
                        ||/var/log/message:所有的登录文件存放目录
                --> /tmp
                    ->存放用户或程序的临时文件，通常为空，任何人都可以访问，重要数据不可放置在此目录下
                --> /dev
                    ->存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备。
                    -> 例如:挂载光驱mount /dev/cdrom /mnt
                --> /usr
                    ->系统存放程序的目录，比如命令、帮助文件等。
                    ->在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。
                    ->当我们安装一个Linux官方提供的软件包时，大多安装在这里。
                    ->如果软件有配置文件，会把配置文件安装在/etc目录中。
                    ->例:
                        ||/usr/bin目录用于存放程序
                        ||/usr/share存放共享的数据，比如音乐或者图标等
                        ||/usr/
                --> /opt
                    ->主机安装软件的额外目录，意思为可选择的，有些软件包也会被安装在这里。
                    ->安装到/opt目录下的程序，它所有的数据、库文件等都放在一个目录下。
                --> /mnt
                    ->用于存放挂载储存设备的挂载目录，不过并不是绝对的,只要愿意，可以随便找一个地方挂载。
                --> /media
                    ->有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘(包括U盘)、CD/DVD驱动器等。
                --> /proc
                    ->存放操作系统运行时的进程信息及内核信息(比如cpu、硬盘分区、内存信息等)。
                    -> /proc/cpuinfo 关于处理器的信息，如类型、厂 家、型号和性能等
                    -> /proc/devices 当前运行内核所配置的所有设备清单
                    -> /proc/interrupts 正在使用的中断，和曾经有多少个中断
                    -> /proc/ioports 当前正在使用的I/O端口
                        ||此文件夹一般挂载内存文件系统，即里面的内存一般存放于内存中，掉电丢失。
        ----Linux文件类型
            --->普通文件
                -->说明
                    ->普通文件是用于存放数据、程序等信息的文件
                    ->一般都长期地存放在外存储器(磁盘) 中。
                    ->普通文件又分为文本文件和二进制文件。
                -->文本文件
                    ->文本文件中保存的是字符的编码，用户可以直接读懂其中的数据，如数字、字母等。
                -->二进制文件(binary file)
                    ->内存中的数据原封不动地保存至文件中，这样的文件称为二进制文件。
            --->目录文件
                -->目录文件是由文件系统中一个目录所包含的目录项所组成的文件
                -->用户进程可以读取目录文件，但不能对它们进行修改，只有系统(内核)才可以修改目录文件。
            --->设备文件
                -->说明
                    ->设备文件是用于为操作系统与设备提供连接的一种文件。
                    ->在Linux系统中将设备作为文件来处理，操作设备就像是操作普通文件一样。
                    ->设备文件又分为字符设备文件和块设备文件。
                    ->每一个设备对应一个设备文件，存放在/dev目录中。
                -->字符设备(Character device)
                    ->这是一种顺序的数据流设备
                    ->对这种设备的读写是按字符进行的，而且这些字符连续地形成了一个数据流
                    ->字符设备不具备缓冲区，所以这种设备的读写是实时的，如串口设备
                -->块设备(Block Device)
                    ->这是一种随机存取设备
                    ->对这种设备的读写是按块进行的
                    ->它使用缓冲区来存放暂时的数据，待条件成熟后，把缓存中的数据一次性写入设备或从设备中一次性读出数据放入到缓冲区，如磁盘
            --->链接文件
                -->说明
                    ->链接提供了共享文件的一种方法，链接又可以分为软链接(符号链接)和硬链接。
                -->软链接
                    ->软链接类似于快捷方式
                    ->软链接文件可以在不同的文件系统之间建立一种链接关系
                    ->删除软链接的源文件，文件就不存在了
                -->硬链接
                    ->硬链接文件是已存在文件的另一个名字，删除硬链接的源文件，文件依然存在
            --->管道文件
                -->管道文件主要用于在进程间传递数据，它是Linux进程间的一种通信机制。
                -->管道是进程间传递数据的“媒介”。
                -->管道分为匿名管道和命名管道
            --->套接口文件
                -->套接口(Socket)文件(也称套接字)主要用于不同计算机间的进程间通信。
                -->套接口有3种类型:流式套接口、数据报套接口、和原始套接口
    ➢Linux 常用命令
        ----命令概述
            --->Linux刚出世时没有什么图形界面,所有的操作全靠命令完成
            --->近几年来, Linux发展的非常迅速,图形界面越来越友好
                -->但是在真正的开发过程中,Linux命令行的应用还是占有非常重要的席位的
            --->许多Linux功能在命令行界面要比图形化界面下运行的快,有些使用Linux的场合甚至没有图形化的界面
            --->可以说不会命令行,就不算会Linux
            --->Linux提供了大量的命令
                -->利用它可以有效地完成大量的工作,如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等
            --->在Linux系统上工作离不开系统提供的命令,要想真正理解Linux系统,就必须从Linux命令学起
                -->通过基础的命令学习可以进一步理解Linux系统
            --->Linux发行版本最少的命令也有200多个,这里只介绍比较重要和使用频率最多的命令。
        ----命令使用方法
            --->Linux命令格式
                -->command [-options] parameter1 ...
            --->说明
                -->command:
                    ->命令名:相应功能的英文单词或单词的缩写
                -->[-options]:
                    ->选项:可用来对命令进行控制,也可以省略
                -->parameter1 ....
                    ->传给命令的参数:可以是零个一个或多个
                -->例:ls -alh /home
            ---> --help
                -->一般是Linux命令自带的帮助信息
                -->如:ls --help
            ---> man(manual)
                -->有问题找男人
                -->man是Linux提供的一个手册,包含了绝大部分的命令、函数使用说明
                -->该手册分成很多章节(section),使用man时可以指定不同的章节来浏览
                -->中文在线手册http://os.51cto.com/linuxman/
                -->例: man Is ; man2 mkdir
            --->自动补全:
                -->在敲出命令的前几个字母的同时,按下tab键,系统会自动帮我们补全命令
            --->历史命令:
                -->当系统执行过一些命令后,可按上下键翻看以前的命令
                -->history将执行过的命令列举出来
            --->重定向:>
                -->本应显示在终端上的内容保存到执行文件中
                -->例如:
                    ->ls > test.txt
                    ->ls --help > test.txt
            --->管道:
                -->一个程序的输出作为另一个程序的输入
                -->例如:
                    ->ls | less
                    ->ls | more
        ----常用命令
            --->用处
                -->文件、磁盘管理
                    ->ls tree clear cd pwd
                    ->mkdir touch rm
                    ->cp mv cat file which
                    ->find grep
                    ->df du mount
                    ->ln tar
                -->用户、权限管理
                    ->adduser deluser 
                    ->passwd su
                    ->chmod chown chgrp
                -->系统管理
                    ->ps top kill
                    ->ifconfig ping
                    ->who exit
                    ->cal date
                    ->shutdown reboot
            --->详情
                --->ls:显示目录内容
                    --> -l:列表显示
                    --> -a:显示隐藏文件
                    --> -h:配合-l以人性化的方式显示文件大小
                    --> 实例:
                        ||
                        ||yyz@yyz-virtual-machine:~$ ls -l
                        ||
                        ||总用量 52
                        ||-rw-r--r-- 1 yyz yyz 8980 3月  16 12:52 examples.desktop
                        ||drwxrwxrwx 4 yyz yyz 4096 3月  16 19:57 share
                        ||drwxr-xr-x 3 yyz yyz 4096 3月  16 18:34 snap
                        ||
                        ||在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种权限来区分
                        ||以文件所有者、同一个组人、其他人3种身份来区分文件权限
                        ||
                        ||上面的例子中
                        ||-rwxr-xr-x 1 dengwei teacher 1879 7月 27 17:19 _vimrc
                        ||drwxrwxr-x 3 qiujuan teacher 4096 11月 19 10:10 xdw
                        ||
                        ||第1个字母代表文件的类型
                        ||  d代表文件夹(目录)、-代表普通文件、c代表硬件字符设备、b 代表硬件块设备、l代表软链接文件、s待变套接字文件
                        ||后9个字母分别代表
                        ||  文件所有者、同组者、其他人拥有的权限
                        ||  分别表达为:rwx(读、写、执行)
                        ||  (即为九位权限)
                        ||第一个数字
                        ||  对于文件:硬链接的个数
                        ||  对于文件夹:代表子文件夹得个数
                        ||后面两个单词
                        ||  第一个:代表文件所有者
                        ||  第二个:代表文件所有组
                --->tree:以树状形式显示目录结构
                    --> -L n(n为要查看的层数)
                        ->系统默认没有此命令
                        ->安装:sudo apt-get install tree
                --->clear:清除终端上的显示
                    -->快捷键: CTRL + L
                --->cd:切换目录
                    --> cd /home 可进入home(指定)目录
                    --> cd.. 可进入上一层目录
                    --> cd - 可进入上一个进入的目录
                    --> cd ~ 可进入用户的家目录
                        ->(-:代指家目录)
                --->pwd:显示当前工作目录的绝对路径
                ---> mkdir:创建目录
                    --> -p 递归地在指定路径建立文件夹,不管目录是否存在,都会创键下层目录
                ---> touch:创建文件
                    --> touch test.c
                ---> rm:删除文件/目录
                    --> rm file1 -rf
                    --> -r:删除文件夹时必须加此参数
                    --> -f:强制地删除文件
                --->cp:复制文件
                    --> cp /etc/profile /home
                        ->将/etc/profile文件复制到/home目录下
                    --> -R:拷贝文件夹
                    --> -i:有重复文件时,提醒是否覆盖
                    --> -V:显示拷贝进度
                ---> mv:移动文件或更改文件名
                    --> mv file1 file2
                    --> mv file1 /home
                    --> -V:同cp
                ---> cat:显示文本文件内容
                    --> cat test
                        ->显示test文件的内容
                ---> file:查看文件类型
                ---> which:查看命令所在的目录
                ---> find:在指定路径下查找指定文件
                    -->用法:find路径名 -name 文件名
                    -->例子:find /home -name test.txt
                        ->在根目录的home目录下查找名为test. txt的文件
                ---> grep:在指定文件中查找指定内容
                    -->用法:grep 查找信息 文件名 参数 -n 显示行号
                    -->例子1: grep aaa test.c -n
                        ->在当前文件test.c中查找aaa信息,并显示行号
                    -->例子2:grep aaa ./* -R -n
                        ->在当前文件夹下的所有文件查找包含a信息的文件
                    -->例子3:ls /bin | grep ls
                        ->配合管道,在前一个命令的输出中查找我们需要的信息
                ---> df:检查磁盘空间占用情况
                    --> df可加上-h参数,使显示人性化
                ---> du:显示目录/文件占用磁盘空间大小
                    -->du可加上-h参数,使显示人性化
                ---> mount:挂载(mount)光盘镜像文件、移动硬盘、U盘、 Windows和NFS网络共享文件
                ---> umount:卸载mount挂载的目录
                ---> tar:压缩与解压缩命令
                    --> gzip格式:
                        ->压缩用法: tar cvzf 压缩包包名 文件1 文件2 ...
                            ||例子: tar zcvf bk.tar.gz *.c
                        ->解压用法: tar xvzf 压缩包包名
                            ||例子: tar zxvf bk.tar.gz
                        ->解压到指定目录:-C
                            ||例子: tar zxvf bk.tar.gz -c ./test
                                //将bk.tar.gz解压到当前目录下的test目录下
                    --> tar xvf
                        -> c:压缩;x:解压;
                        -> v:显示进度;
                        -> j:格式bz2; z; gz;
                        -> f:压缩包名字指定
                    -->bz2格式:
                        ->压缩用法: tar jcvf 压缩包包名 文件1 文件2 ...
                        ->例子: tar jcvf bk.tar.bz2 *.c
                        ->解缩用法: tar jxvf 压缩包包名
                            ||例子: tar jxvf bk.tar.bz2
                        ->解压到指定目录:-C
                            ||例子: tar jxvf bk.tar.gz -C ./
                    -->压缩格式
                        -> *.bz2 (压缩算法好、压缩比例大、费时)
                        -> *.gz
                ---> adduser: adduser test --> 增加一个叫test的用户
                ---> deluser: deluser test --> 删除一个叫test的用户
                ---> passwd: passwd 用户名
                    --> passwd修改指定用户的密码,若不写用户名,则修改当前用户密码
                ---> su : su 用户名
                    --> su可让用户暂时变更登入的身份
                    --> 变更时须输入所要变更的用户帐号与密码
                ---> chmod:改变文件权限
                    --> chmod有两种使用格式(字母法与数字法)
                    --> 各字母的含义
                        -> u: user,即文件或目录的拥有者
                        -> g: group,即文件或目录的所属群组
                        -> o: other,除了文件或目录拥有者或所属群组之外
                        -> a: All,即全部的用户
                    --> 有关权限代码
                        -> r:读取权限,数字代号为"4"
                        -> W:写入权限,数字代号为"2"
                        -> x:执行或切换权限,数字代号为"1"
                        -> -:不具任何权限,数字代号为"O"
                    --> chmod语法格式
                        -> chmod o+w filename --> 给文件file的其它用户增加写权限
                        -> chmod u-r filename --> 给文件file的拥有者减去读的权限
                        -> chmod g=x filename --> 设置文件file的同组用户的权限为可执行,同时去除读、写权限
                        -> chmod 751 file
                            ||给文件所有者:读、写、执行权限
                            ||同组用户:读、执行的权限
                            ||其它用户:执行的权限
                        -> chmod 777 file
                            ||对所有用户拥有读、写、执行权限
                            ||-R 递归所有目录加上相同权限
                        -> chmod 777 test -R
                            ||递归test目录下所有文件加777权限
                    --> chown:改变文件所属人
                        -> chown teacher test/
                            ||将test文件夹的所属人改为 teacher
                            ||teacher必须为Linux中已存在用户
                    -->补充:linux命令--umask
                        ->网址:https://www.cnblogs.com/sench/p/8933638.html
                ---> chgrp:改变文件所属组
                    -->chgrp teacher test/
                        ->将test文件夹的所属组改为teacher
                        ->teacher必须为Linux中已存在用户组
                ---> ps:查看系统进程
                    --> ps-aux 打印出所有进程
                    --> ps-e 查看系统中所有的进程
                ---> top:显示、管理执行中的程序
                ---> kill:杀死指定进程号的进程,配合ps使用
                    --> kill-9 63371
                        -> -9代表强制结束
                ---> ifconfig  查看或配置网卡信息
                    --> ifconfig ethO0  查看网卡信息
                    --> ifconfig eth0 192.168.220.xx  设置ip
                    --> ifconfig eth0 hw ether 12:34:56:78:23:56
                        ->设置mac地址,多用于开发板
                ---> ping:测试网络连通性
                    -->ping 192.168.1.123 -c 5
                        -> -C 代表发送包的次数
                ---> Who:查看当前系统登录用户的信息
                    -->第一列显示登陆用户名
                    -->第二列显示终端名
                    -->第三列显示登陆时间
                ---> exit
                    -->如果是图形界面:退出当前终端
                    -->如果是使用ssh远程登录:退出登陆账户
                ---> cal:显示日历
                    -->命令格式: $cal [选项] [月份] [年]
                    -->选项: -y 显示整年日历
                    --> cal 9 2012
                ---> date:显示日期
                ---> shutdown:关机
                    --> shutdown -h now
                        ->立刻关机,其中now相当于时间为0的状态
                    --> shutdown -h 20:25
                        ->系统在今天的20:25会关机
                    --> shutdown -h +10
                        ->系统再过十分钟后自动关机
                    --> reboot:重启电脑
                --->ifconfig -a
                    -->查询ip地址
            --->练习
                (1)在~目录下建立一个名为cmd_test的目录
                (2)进入cmdtest目录
                (3)将文件/lib/目录下所有以包含.so(*.so*)的文件复制到cmd_test目录下
                (4)将cmd_test目录下后缀为.so文件打包成so.tar.bz2
                (5)将cmd_test目录下后缀为.so的文件打包并压缩为so.tar.gz
                (6)在cmd_test目录下创建c_test文件夹
                (7)将so.tar.gz解压到c_test目录下
                (8)将so.tar.gz删除
                (9)修改so.tar.bz2的权限,要求仅文件的所有者拥有读、写、执行权限,其余人和同组人没有任何权限
                (10)使用>将/dev目录下的所有文件名保存在cmd_test下的dev.txt中
                (11)使用grep命令找出其中console出现的位置
    ➢Linux 文本编辑器vi+gedit
        ----vi+gedit概述
            (1)vi
                ----vi编辑器是Linux系统中最常用的文本编辑器
                ----几乎所有的Linux发行版中都包含vi程序
                ----vi工作在字符模式下，不需要图形界面，非常适合远程及嵌入式工作,是效率很高的文本编辑器
                ----尽管在Linux上也有很多图形界面的编辑器可用，但vi的功能是那些图形编辑器所无法比拟的。
            (2)gedit
                ----gedit是一个Linux环境下的文本编辑器
                ----类似windows下的写字板程序，在不需要特别复杂的编程环境下，作为基本的文本编辑器比较合适
                ----使用:
                    --->在字符界面下，直接使用:gedit file1.txt 即可
        ----vim+ctags安装
            (1)vim
                ----(介绍)
                    --->vim是vi的升级版，它不仅兼容vi的所有指令，而且还有一些新的特性，例如vim可以撤消无限次、支持关键词自动完成、可以用不同的颜色来高亮你的代码。
                    --->官网:http://www.vim.org/download.php
                ----安装指令
                    --->sudo apt-get install vim
            (2)ctags
                ----(介绍)
                    --->ctags是vim下方便代码阅读的工具，是个很强大的vim插件，有了它浏览代码时可以在函数, 变量之间跳来跳去等等。
                    --->官网:http://ctags.sourceforge.net/
                ----安装指令
                    --->sudo apt-get install ctags
        ----vi使用
            (1)配置vim
                ----step1
                    ①将 vim_configure拷入当前用户的目录下
                    ②进入vim_configure
                    ③写权限: sudo chmod77 copy_con.sh
                ----step2:打开终端，执行以下以下命令
                    --> cd vim_configure
                    --> sudo ./copy_con.sh
                    --> 拷贝成功后，出现copy successful
                ----配置文件的作用
                    1)自动添加创建时间、名称等注释信息
                    2)自动添加行号
                    3)支持鼠标点击定位
                    4)支持函数列表功能(F9打开或关闭)
                    5)支持多文件打开功能(F5)
                    6)支持函数跟踪、跳转(Ctrl+]、Ctrl+o)
                    7)支持vim快捷键.pdf中的快捷键。
                ----最后我们来介绍插件的这些特殊用法
                    --->vi filename
                        -->打开或新建文件,并将光标置于第一行行首
                    --->vi +n filename
                        -->打开文件,并将光标置于第n行行首
            (2)vim编辑器有3个操作模式
                1)vi插入模式
                    ---> vi创建一个不存在文件时,默认进入插入模式
                    ---> vi将输入的字符作为正文内容放在正在编辑的文件中
                2)vi编辑模式
                    ---> vi打开一个已经存在文件时,默认进入编辑模式
                    ---> 在此模式下可进入插入模式、控制屏幕光标的移动、进行文本的选择、复制、粘贴、剪切、删除、查找等工作。
                3)vi最后一行模式(命令模式)
                    ---> 在编辑模式下,按 shift+:进入
                    ---> 跟编辑模式类似,完成存盘、另存、查找等任务
                    ---> q!强退  w!强写
            (3)vi编辑器模式切换
                1)由编辑模式切换到插入模式
                    ---> i --> 从光标当前位置开始插入
                    ---> a --> 从光标当前位置的下一个字符开始插入
                    ---> o --> 在光标位置的下行插入一个空行,再进行插入
                    ---> I --> 从光标所在行的开头开始插入正文
                    ---> A --> 从光标所在行的末尾开始插入正文
                    ---> O --> 在光标位置的上一行插入一个空行,再进行插入
                2)由编辑模式切换到命令模式
                    ---> shift+:
                3)由插入模式、命令模式切换到编辑模式
                    ---> ESC(命令模式到编辑模式两次ESC)
                4)编辑模式与插入模式不能直接转换
            (4)编辑模式下删除和修改文本
                1)  u                               撤消前面多次修改。
                2)  [n]                             删除光标后n个字符。
                3)  [n]X                            删除光标前n个字符。
                4)  [n]dd                           删除从当前行开始的n行。
                5)  [n]yy                           复制从当前行开始的n行。
                6)  p                               把粘贴板上的内容插入到当前行。
                7)  .                               执行上一次操作
                8)  shift+zz(按住 shift按两下z键)    保存退出当前文件
            (5)常用最后一行模式命令
                ----文件存储类
                    :W                  保存当前文件
                    :w file             另存当前文件为fi1e
                    :q                  退出vi
                    :wq                 保存当前文件,退出
                    :x                  同上
                    :q!                 不保存文件并退出
                ----配合搜索命令使用
                    :nohls              取消高亮
                    :set hIs            设置高亮
                    :set ignorecase     让VIM忽略大小写
                    :set noignorecase   不让VIM忽略大小写
                    :set nu/number      行号显
                    :set nonu/no number 行号关
    ➢Linux shell脚本编程
        ----shell概述
            --->shell的两层含义
                1)作为应用程序
                    ----简述
                        --->交互式地解释、执行用户输入的命令
                        --->将用户的操作翻译成机器可以识别的语言，完成相应功能
                    ----称之为shell命令解析器
                        --->shell是用户和Linux内核之间的接口程序
                        --->用户在提示符下输入的命令都由shell先解释然后传给Linux核心
                        --->它调用了系统核心的大部分功能来执行程序、并以并行的方式协调各个程序的运行
                    ----Linux系统中提供了好几种不同的shell命令解释器，如:
                        --->sh
                        --->ash
                        --->bash
                        --->...
                    ----一般默认使用bash作为默认的解释器
                    ----我们后面编写的shell脚本，都是由上述shell命令解释器解释执行的。
                2)作为程序设计语言
                    ----简述
                        --->它定义了各种变量和参数
                        --->并提供了许多在高级语言中才具有的控制结构，包括循环和分支
                        --->完成类似于windows下批处理操作，简化我们对系统的管理与应用程序的部署
                    ----称之为shell脚本
                        --->我们学过的C/C++等语言，属于编译性语言
                        --->(编写完成后需要使用编译器完成编译、汇编、链接等过程变为二进制代码方可执行)
                        --->shell脚本是一种脚本语言，我们只需使用任意文本编辑器，按照语法编写相应程序，增加可执行权限，即可在安装shell命令解释器的环境下执行
                    ----shell脚本主要用于
                        --->帮助开发人员或系统管理员将复杂而又反复的操作放在一个文件中，通过简单的一步执行操作完成相应任务，从而解放他们的负担
        ----shell应用举例
            1)《linux常用命令_练习.txt》
                ----我们前面完成了这个练习，步骤很多
                ----其实 我们只需要将所有操作写入一个文件---- cmd.sh(名字跟后缀可任取，为了便于区分我们一般写为*.sh形式)
                ----然后:
                    --->chmod +x cmd.sh ./cmd.sh
                    --->直接执行即可
            2)假设我们要完成以下任务:
                ----判断用户家目录下(~)下面有没有一个叫test的文件夹
                    --->如果没有，提示按y创建并进入此文件夹，按n退出
                    --->如果有，直接进入，提示请输入一个字符串，并按此字符串创建一个文件
                    --->如果此文件已存在，提示重新输入，重复三次自动退出，不存在创建完毕，退出
                --->简单的进行命令堆积无法完成以上任务，这就需要学习相应的shell脚本语法规则了
        ----shell语法
            1)shell脚本的定义与执行
                ----定义以开头: #!/bin/sh
                    ---> #! 用来声明脚本由什么shell解释,否则使用默认shell
                ----单个"#"号代表注释当前行
                ----执行方式:
                    ---> #chmod +x test.sh  ./test.sh   增加可执行权限后执行
                    ---> #bash test. sh                 直接指定使用bash解释test.sh
                    ---> #.  test.sh(或者 source test.sh)    调用默认shell解释test.sh
                ----三种执行脚本的方式不同点
                    --->./和bash执行过程基本一致
                        -->后者明确指定bash解释器去执行脚本，脚本中#!指定的解释器不起作用
                        -->前者首先检测#!，使用#!指定的shell，如果没有使用默认的shell
                    --->用./和bash去执行会在后台启动一个新的shell去执行脚本
                    --->用.去执行脚本不会启动新的shell,直接由当前的shell去解释执行脚本
            2)变量
                ----自定义变量
                    --->定义变量
                        -->变量名 = 变量值 如:num = 10
                    --->引用变量
                        -->$变量名 如:i = $num
                        -->把变量num的值赋值给变量i
                    --->显示变量
                        -->使用echo命令可以显示单个变量取值
                        -->echo $num
                    --->清除变量
                        -->使用unset命令清除变量
                        -->unset varname
                    --->变量的其它用法
                        -->read string
                            --从键盘输入一个字符串付给变量string，若string没定义则先定义在使用
                        -->readonly var=100
                            --定义一个只读变量,只能在定义时初始化,以后不能改变,不能被清除。
                        -->export var=300
                            --使用export说明的变量，会被导出为环境变量，其它shell均可使用 
                            --注意:此时必须使用source 2_var.sh才可以生效
                    --->注意事项
                        -->变量名只能英文字母数字下划线，不能以数字开头
                            -- 1_num = 10 ---> 错误
                            -- num_1 = 20 ---> 正确
                        -->等号两边不能直接接空格符
                            --若变量中本身就包含了空格，则整个字符串都要用双引号、或单引号括起来；
                            --双引号内的特殊字符可以保有变量特性， 但是单引号内的特殊字符则仅为一般字符。
                            --例如:
                                ->name=aa bb                //错误
                                ->name="aa bb"              //正确
                                ->echo "$name is me"        //输出: aa bb is me
                                ->echo '$name is me'        //输出: $name is me
                ----环境变量
                    --->shell在开始执行时就已经定义了一些和系统的工作环境有关的变量
                        -->我们在shell中可以直接使用 $name引用
                    --->定义
                        -->一般在 ~/.bashrc 或 /etc/profile 文件中(系统自动调用的脚本)
                        -->使用export设置，允许用户后来更改
                            --例如: VARNAME = value ；export VARNAME
                    --->传统上，所有环境变量均为大写
                    --->显示环境变量
                        -->使用 env 命令可以查看所有的环境变量。
                    --->清除环境变量
                        -->使用unset命令清除环境变量
                    --->常见环境变量
                        --> HOME  --->  用于保存注册目录的完全路径名。
                        --> PATH  --->  用于保存用冒号分隔的目录路径名
                            -- shell将按PATH变量中给出的顺序搜索这些目录
                            -- 找到的第一个与命令名称一致的可执行文件将被执行。
                            --  PATH=$HOME/bin: /bin: /usr/bin;
                                export PAth
                        --> HOSTNAME  --->  主机名
                        --> SHELL  --->  默认的 shell命令解析器
                        --> LOGNAME  --->  此变量保存登录名
                        --> PWD  --->  当前工作目录的绝对路径名
                        --> ......
                    --->预定义变量
                        --> $#  --->  传给shell脚本参数的数量
                        --> $*  --->  传给shell脚本参数的内容
                        --> $1、$2、$3、...、$9  --->  运行脚本时传递给其的参数，用空格隔开
                        --> $?  --->  命令执行后返回的状态
                            -- "$?" 用于检查上一个命令执行是否正确
                            -- 在Linux中，命令退出状态为0表示该命令正确执行，任何非0值表示命令出错。
                        --> $0:当前执行的进程名
                        --> $$:当前进程的进程号
                            -- "$$"变量最常见的用途是用作临时文件的名字
                            -- 以保证临时文件不会重复
                    --->脚本变量的特殊用法:"" `` ' \ () {}
                        --> ""(双引号)  --->  包含的变量会被解释
                        --> ''(单引号)  --->  包含的变量会当做字符串解释
                        --> ``(数字键1左面的反引号)  --->  反引号中的内容作为系统命令，并执行其内容，可以替换输出为一个变量
                            -- $ echo "today is `date` "
                            -- today is 2012年07月29日星期日 12:55:21 CST
                        --> \ 转义字符  --->  同c语言
                            -- \n \t \r \a等
                            -- echo命令需加-e转义
                            -- echo -e "this \n is \t a \n test"
                        --> (命令序列)  --->  由子shell来完成,不影响当前shell中的变量
                        --> {命令序列}: 在当前shell中执行，会影响当前变量
                            --注意: “{”、“}” 前后有一空格
            4)条件测试语句
                ----简述
                    --->在写shell脚本时，经常遇到的问题就是判断字符串是否相等，可能还要检查文件状态或进行数字测试，只有这些测试完成才能做下一步动作
                    --->test命令:用于测试字符串、文件状态和数字
                    --->test命令有两种格式
                        -->test condition
                        -->[ condition ]
                        -->使用方括号时，要注意在条件两边加上空格
                    --->shell脚本中的条件测试
                        -->文件测试
                        -->字符串测试
                        -->数字测试
                        -->复合测试
                    --->测试语句一般与后面讲的条件语句联合使用
                ----文件测试:测试文件状态的条件表达式
                    ---> -e 是否存在
                    ---> -d 是目录
                    ---> -r 可读
                    ---> -w 可写
                    ---> -f 是文件
                    ---> -x 可执行
                    ---> -L 符号连接
                    ---> -c 是否字符设备
                    ---> -b 是否块设备
                    ---> -s 文件非空
                    ---> 例如:
                        ||    test -f /home
                        ||    echo $?
                        ||
                        ||    [ -r test_sh ]
                        ||    echo $?
                 ----字符串测试
                    ---> test str_operator “str”
                    ---> test “str1” str_operator “str2”
                    ---> [ str_operator “str” ]
                    ---> [ “str1” str_operator “str2”]
                    --->其中str_operator可以是
                        --> = 两个字符串相等
                        --> != 两个字符串不相等
                        --> -z 空串
                        --> -n 非空串
                    ---> 例如:
                        ||test -z $yn
                        ||echo $?
                ----数字测试
                    --->测试数值格式如下
                        --> test num1 num_operator num2
                        --> [ num1 num_operator num2 ]
                    --->num_operator可以是
                        --> -eq 数值相等
                        --> -ne 数值不相等
                        --> -gt 数1大于数2
                        --> -ge 数1大于等于数2
                        --> -le 数1小于等于数2
                        --> -lt 数1小于数2
                ----命令执行控制
                    --->&&
                        --> command1 && command2
                            -- &&左边命令(command1)执行成功(即返回0),shell才执行&&右边的命令(command2)
                    --->||
                        --> command1 || command2
                            -- ||左边的命令(command1)未执行成功(即返回非0),shell才执行||右边的命令(command2)
                    --->例如
                        --> test -e /home && test -d /home && echo "true" 
                        --> test 2 -lt 3 && test 5 -gt 3 && echo "equal"
                        --> test "aaa"="aaa" || [ "$yn" = "y" ]&& echo "equal"
            5)控制语句
                ----if 
                    --->格式一
                        ||
                        ||      if [条件1]; then
                        ||          执行第一段程序
                        ||      else
                        ||          执行第二段程序
                        ||      fi
                        ||
                    --->格式二
                        ||
                        ||      if [条件1]; then
                        ||          执行第一段程序
                        ||      elif [条件2]；then
                        ||          执行第二段程序
                        ||      else
                        ||          执行第三段程序
                        ||      fi
                        ||
                ----case 
                    --->格式
                        ||
                        ||      case $变量名称 in
                        ||          “第一个变量内容”) 
                        ||              程序段一 
                        ||              ;;
                        ||          “第二个变量内容”)
                        ||              程序段二
                        ||              ;;
                        ||          *)
                        ||              其它程序段
                        ||              exit 1
                        ||      esac
                ----for 
                    --->格式一
                        ||
                        ||      for (( 初始值; 限制值; 执行步阶 )) 
                        ||      do
                        ||          程序段
                        ||      done
                        ||
                            ->初始值:变量在循环中的起始值
                            ->限制值:当变量值在这个限制范围内时，就继续进行循环
                            ->执行步阶:每作一次循环时，变量的变化量
                        --> declare是bash的一个内建命令，可以用来声明shell变量、设置变量的属性。
                           ->declare也可以写作typeset。
                        -->declare -i s 代表强制把s变量当做int型参数运算。
                    --->格式二
                        ||
                        ||      for var in con1 con2 con3 ... 
                        ||      do
                        ||          程序段
                        ||      done
                        ||      第一次循环时，$var的内容为con1
                        ||      第二次循环时，$var的内容为con2
                        ||      第三次循环时，$var的内容为con3
                        ||      ......
                ----while
                    --->格式
                        ||
                        ||      while [ condition ]
                        ||      do
                        ||          程序段
                        ||      done
                            -->当condition成立的时候进入while循环， 直到condition不成立时才退出循环。
                ----until
                    --->格式
                        ||
                        ||      until [ condition ] 
                        ||      do
                        ||          程序段
                        ||      done
                            -->这种方式与while恰恰相反，当condition成立的时候退出循环，否则继续循环。
                ----break  VS  continue
                    --->break
                        -->break命令允许跳出循环。 
                        -->break 通常在进行一些处理后退出循环或case 语句
                    --->continue
                        -->continue命令类似于break命令
                        -->只有一点重要差别，它不会跳出循环，只是跳过这个循环步
            6)函数
                ----简述
                    --->有些脚本段间互相重复，如果能只写一次代码块而在任何地方都能引用那就提高了代码的可重用性。
                    --->shell允许将一组命令集或语句形成一个可用块， 这些块称为shell函数。
                    --->函数可以放在同一个文件中作为一段代码，也可以放在只包含函数的单独文件中
                    --->所有函数在使用前必须定义，必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用
                ----定义函数的两种格式:
                    1)      函数名(){
                                命令 ...
                            }
                    2)      function 函数名() {
                                命令 ...
                            }
                ----调用函数的格式为
                    ---> 函数名 param1 param2……
                ----使用参数同在一般脚本中使用特殊变量$1，$2 ...$9一样
                ----函数可以使用return提前结束并带回返回值
                    ---> return 从函数中返回，用最后状态命令决定返回值。
                        --> return 0 无错误返回
                        --> return 1 有错误返回
            7)系统shell启动顺序
    ➢Linux 编译器gcc
        1)GCC概述
            ----GCC简介
                ---编译器是将易于编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低级机器语言的程序。
                --- GUN项目中的一个子项目GCC(GNU Compiler Collection，GNU编译器套装)
                    -->是一个编译器套装，是GNU计划的关键部分，也是GUN最优秀的软件之一。 
                ---GCC最初用于编译C语言
                    -->随着项目的发展，GCC已经成为了能够编译C、C++、Java、Ada、 fortran、Object C、Object C++、Go语言的编译器大家族。
            ----GCC的组成
                --->GCC由
                    ||  cpp(预处理器)
                    ||  gcc(C编译器)
                    ||  g++(C++编译器)
                    ||  binutils(Binary Utilities 二进制工具)
                    ||等工具组成。
                        ----binutils是辅助GCC的主要软件，常用的工具有
                            ||  as(汇编器)
                            ||  ld(链接器)
                            ||  ar(ar 工具)
                            ||  等等。
        2)gcc命令 
            ----简介
                --->gcc仅仅作为真实的编译器和链接器的入口
                    -->它会在需要的时候调用其它组件(预处理器、汇编器、连接器)，并且会传一些额外的参数给编译器和连接器。
                    -->输入文件的类型和传给gcc的参数决定了gcc调用哪些组件。
                --->gcc识别的文件扩展名如下
                    ||  .c      C语言文件
                    ||  .i      预处理后的C语言文件
                    ||  .C、.cc、.cp、.cpp、.c++、.cxx          C++语言文件
                    ||  .m      Objective-C 原始程序
                    ||  .ii     预处理后的C++语言文件
                    ||  .S      汇编文件
                    ||  .s      预处理后的汇编文件
                    ||  .o      编译后的目标文件
                    ||  .a      目标文件的静态链接库(链接时使用)
                    ||  .so     目标文件的动态链接库(链接、运行时使用)
            ----编译命令格式
                --->    gcc [-option1] ... <filename>
                --->    g++ [-option1] ... <filename>
                    ||  1.命令、选项和源文件之间使用空格分隔 
                    ||  2.一行命令中可以有零个、一个或多个选项 
                    ||  3.文件名可以包含文件的绝对路径，也可以使用相对路径。
                    ||  4.如果命令中不包含输出可执行文件的文件名，可执行文件的文件名默认为a.out。
            ----gcc、g++编译选项
                ||  -o file   --->   指定生成的输出文件名为file
                ||  -E   --->   只进行预处理
                ||  -S   --->   只进行预处理和编译
                ||  -c   --->   只进行预处理、编译和汇编
                ||  -Wall   --->   生成所有级别的警告信息
                ||  -w   --->   关闭所有警告，建议不使用此选项
                ||  -O[0-3]   --->   编译器优化级别
                ||                   数值越大级别越高，0表示不优化
                ||  -include file   --->   插入一个文件
                ||                         等同于源代码中的#include
                ||  -Dmacro[=def]   --->   将名为marco的宏定义为def
                ||                         等同于#define macro [def]
                ||                         若[def]忽略不写，则macro等于1
                ||  -Umacro   --->   取消宏的定义
                ||                   等同于源代码中的#undef macro
                ||  -v   --->   显示制作GCC工具时的配置命令
                ||              显示预处理器、编译器的版本号
                ||  -Idir  --->   将dir目录加入头文件搜索目录列表
                ||                      ===>/user/include
                ||                优先在dir目录中查找包含的头文件
                ||                    ----当前找 ->库里找 -> -I指定找
                ||  -Ldir  --->   将dir目录加入头文件搜索目录列表
                ||                优先在dir目录中查找包含的头文件
                ||  -lname  --->   链接库为name的库
                ||  -static  --->   链接时使用静态库
                ||  -shared  --->   编译动态库
                ||  -g  --->   在可执行文件中加入标准调试信息
            ----gcc、g++的编译过程
                1)预处理
                2)编译
                3)汇编
                4)链接
                --->编译过程示意图:E:\学习笔记\其他资料\Linux\Image\gcc编译过程示意图.jpg
            ----gcc常用编译应用实例
                --->例1
                    ||      gcc -E hello.c -o hello.i
                    ||      gcc -S hello.i -o hello.s 
                    ||      gcc -c hello.s -o hello.o
                    ||      gcc hello.o -o hello_elf
                ----例2
                    ||      gcc hello.c -o hello_elf
        3)动态库与静态库
            ----链接过程生成可执行代码
            ----链接分为两种
                1)静态链接(.a)
                    ----含义
                        --->由链接器在链接时将库的内容加入到可执行程序中
                    ----特点
                        --->优点
                            -->对运行环境的依赖性较小,具有较好的兼容性
                        --->缺点
                            -->生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间
                            -->库函数有了更新，必须重新编译应用程序
                2)动态链接(.so)
                    ----含义
                        --->连接器在链接时仅仅建立与所需库函数的之间的链接关系
                        --->在程序运行时才将所需资源调入可执行程序
                    ----特点
                        --->优点
                            -->在需要的时候才会调入对应的资源函数
                            -->简化程序的升级
                            -->有着较小的程序体积
                            -->实现进程之间的资源共享(避免重复拷贝)
                        --->缺点
                            -->依赖动态库，不能独立运行
                            -->动态库依赖版本问题严重
            ----前面我们编写的应用程序大量用到了标准库函数
                --->使用gcc hello.c –o hello时
                    -->系统默认采用动态链接的方式进行编译程序
                    -->若想采用静态编译，加入-static参数
            ----分别采用动态编译、静态编译时文件对比
                --->指令
                    ||  gcc hello.c –o hello_share 
                    ||  gcc hello.c –static –o hello_static
                --->对比图
                    -->E:\学习笔记\其他资料\Linux\Image\动静态链接对比.jpg
            ----动态链接库与静态链接库的制作与使用 
            --->下面我们以把自己编写的函数分别制作为动态库与静态库为例讲解如何制作、使用两种库函数
                -->项目代码
                    ||
                    ||          mylib.h
                    ||  extern int max(int x,int y)
                    ||  extern int min(int x,int y)
                    ||
                    ||          mylib.c
                    ||  int max(int x,int y)
                    ||  {
                    ||      return x > y ? x : y;  
                    ||  }
                    ||  
                    ||  int min(int x, int y)
                    ||  {
                    ||      return x < y ? x : y;
                    ||  }
                    ||
                    ||          mytest.c
                    ||
                    ||#include <stdio.h>
                    ||#include "mylib.h"
                    ||
                    ||int main(int argc,char *argv[])
                    ||{
                    ||    int a = 10,b = 20,max_num,min_num;
                    ||    max_num = max(a,b);
                    ||    min_num = min(a,b);
                    ||    printf("max=%d\n",max_num);
                    ||    printf("min=%d\n",min_num);
                    ||}
                    ||
                -->制作静态链接库
                    ->静态链链接库在linux中后缀为.a，以lib开头 
                        --如:libtestlib.a
                    1)制作
                        ||  #gcc -c mylib.c -o mylib.o      //编译目标文件
                        ||  #ar rc libtestlib.a mylib.o     //制作静态库
                        ----静态库多个文件,必须先做成.o
                    2)静态库使用
                        Ⅰ)库函数、头文件均在当前目录下
                            ||  #gcc -o my_test mytest.c libtestlib.a
                            ----库名放在最后
                        Ⅱ)库函数、头文件假设在/opt目录
                            ||  #gcc -o mytest mytest.c -L/opt -ltestlib -I/opt
                            ----不屑lib....a
                    3)编译程序时
                        ----编译程序时
                            --->编译器默认会到/lib/、/usr/lib下查找库函数
                            --->到/usr/include下查找头文件
                        Ⅰ)将libmylib.a移到/lib或/usr/lib下
                            ||  #mv libtestlib.a /lib
                        Ⅱ)将mylib.h移到/usr/include下
                            ||  #mv mylib.h /usr/include
                        Ⅲ)编译
                            ||   #gcc mytest.c -o mytest -ltestlib
                            --->编译器会自动到/lib下查找库文件
                            --->到 /usr/include 下查找头文件
                -->制作动态链接库
                    ----#gcc -shared mylib.c -o libtestlib.so
                        --->使用gcc编译、制作动态链接库
                    ----动态链接库的使用1
                        1)库函数、头文件均在当前目录下
                            ||  #gcc -o my_test mytest.c libtestlib.so
                        2)库函数、头文件假设在/opt目录
                            ||  #gcc -o mytest mytest.c -L/opt -ltestlib -I/opt
                            ----编译通过，运行时出错
                                --->编译时找到了库函数，但链接时找不到库
                                --->执行以下操作，把当前目录加入搜索路径
                                    ||  #export LD_LIBRARY_PATH=./:/opt:$LD_LIBRARY_PATH
                                    ||  #./mytest 可找到动态链接库
                    ----动态链接库的使用2
                        1)库函数、头文件均在系统路径下
                            ||  #cp libtestlib.so /lib
                            ||  #gcc mytest.c -o mytest -ltestlib
                            ||  #./mytest
                                ----编译运行都不会出错
                ----问题
                    --->我们前面的静态库也是放在/lib下，那么连接的到底是动态库还是静态库呢？
                    --->当静态库与动态库重名时，系统会优先连接动态库，或者我们可以加入-static指定使用静态库
    ➢Linux 调试器gdb
        ----简介
            --->GNU工具集中的调试器是gdb
                -->该程序是一个交互式工具，工作在字符模式。
            --->除gdb外，linux下比较有名的调试器还有
                -->xxgdb, ddd, kgdb, ups
            --->gdb是功能强大的调试器，可完成如下调试任务
                -->1、设置断点
                -->2、监视程序变量的值
                -->3、程序的单步执行
                -->4、显示/修改变量的值
                -->5、显示/修改寄存器
                -->6、查看程序的堆栈情况
                -->7、远程调试
        ----gdb示例
            ||      hchen/test> gdb tst <---------- 启动GDB
            ||      GNU gdb 5.1.1
            ||      Copyright 2002 Free Software Foundation, Inc.
            ||      GDB is free software, covered by the GNU General Public License, and you are
            ||      welcome to change it and/or distribute copies of it under certain conditions.
            ||      Type "show copying" to see the conditions.
            ||      There is absolutely no warranty for GDB. Type "show warranty" for details.
            ||      This GDB was configured as "i386-suse-linux"...
            ||      (gdb) l <-------------------- l命令相当于list，从第一行开始例出原码。
            ||      1 #include
            ||      2
            ||      3 int func(int n)
            ||      4 {
            ||      5 int sum=0,i;
            ||      6 for(i=0; i)
            ||      7 {
            ||      8 sum+=i;
            ||      9 }
            ||      10 return sum;
            ||      (gdb) <-------------------- 直接回车表示，重复上一次命令
            ||      11 }
            ||      12
            ||      13
            ||      14 main()
            ||      15 {
            ||      16 int i;
            ||      17 long result = 0;
            ||      18 for(i=1; i<=100; i++)
            ||      19 {
            ||      20 result += i;
            ||      (gdb) break 16 <-------------------- 设置断点，在源程序第16行处。
            ||      Breakpoint 1 at 0x8048496: file tst.c, line 16.
            ||      (gdb) break func <-------------------- 设置断点，在函数func()入口处。
            ||      Breakpoint 2 at 0x8048456: file tst.c, line 5.
            ||      (gdb) info break <-------------------- 查看断点信息。
            ||      Num Type Disp Enb Address What
            ||      1 breakpoint keep y 0x08048496 in main at tst.c:16
            ||      2 breakpoint keep y 0x08048456 in func at tst.c:5
            ||      (gdb) r <--------------------- 运行程序，run命令简写
            ||      Starting program: /home/hchen/test/tst
            ||      
            ||      Breakpoint 1, main () at tst.c:17 <---------- 在断点处停住。
            ||      17 long result = 0;
            ||      (gdb) n <--------------------- 单条语句执行，next命令简写。
            ||      18 for(i=1; i<=100; i++)
            ||      (gdb) n
            ||      20 result += i;
            ||      (gdb) n
            ||      18 for(i=1; i<=100; i++)
            ||      (gdb) n
            ||      20 result += i;
            ||      (gdb) c <--------------------- 继续运行程序，continue命令简写。
            ||      Continuing.
            ||      result[1-100] = 5050 <----------程序输出。
            ||      
            ||      Breakpoint 2, func (n=250) at tst.c:5
            ||      5 int sum=0,i;
            ||      (gdb) n
            ||      6 for(i=1; i<=n; i++)
            ||      (gdb) p i <--------------------- 打印变量i的值，print命令简写。
            ||      $1 = 134513808
            ||      (gdb) n
            ||      8 sum+=i;
            ||      (gdb) n
            ||      6 for(i=1; i<=n; i++)
            ||      (gdb) p sum
            ||      $2 = 1
            ||      (gdb) n
            ||      8 sum+=i;
            ||      (gdb) p i
            ||      $3 = 2
            ||      (gdb) n
            ||      6 for(i=1; i<=n; i++)
            ||      (gdb) p sum
            ||      $4 = 3
            ||      (gdb) bt <--------------------- 查看函数堆栈。
            ||      #0 func (n=250) at tst.c:5
            ||      #1 0x080484e4 in main () at tst.c:24
            ||      #2 0x400409ed in __libc_start_main () from /lib/libc.so.6
            ||      (gdb) finish <--------------------- 退出函数。
            ||      Run till exit from #0 func (n=250) at tst.c:5
            ||      0x080484e4 in main () at tst.c:24
            ||      24 printf("result[1-250] = %d 
            ||      ", func(250) );
            ||      Value returned is $6 = 31375
            ||      (gdb) c <--------------------- 继续运行。
            ||      Continuing.
            ||      result[1-250] = 31375 <----------程序输出。
            ||      
            ||      Program exited with code 027. <--------程序退出，调试结束。
            ||      (gdb) q <--------------------- 退出gdb。
            ||      hchen/test>
        ----使用
            1)前提准备
                ----一般来说GDB主要调试的是C/C++的程序。
                ----要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。
                ----使用编译器(cc/gcc/g++)的 -g 参数可以做到这一点。
                    --->例如:
                        ||   gcc -g hello.c -o hello
                        ||   g++ -g hello.cpp -o hello
                            ----如果没有-g，你将看不见程序的函数名、变量名
                            ----所代替的全是运行时的内存地址。
            2)启动GDB
                ----启动GDB的方法有以下几种
                    1)  gdb program
                        ----program也就是你的执行文件，一般在当前目录下。
                    2)  gdb <program> <core dump file>
                        gdb program core.11127
                        ----用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。
                    3)  gdb <program> <PID>
                        gdb hello 11127
                        ----如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。
                        ----gdb会自动attach上去，并调试他。
                        ----program应该在PATH环境变量中搜索得到。
                ----GDB交互命令
                    --->启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；
                    --->注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率
                    1)运行
                        ||  run
                            ----简记为r
                            ----其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令；
                        ||  continue
                            ----简写c
                            ----继续执行，到下一个断点处(或运行结束)；
                        ||  next
                            ----简写n
                            ----单步跟踪程序，当遇到函数调用时，也不进入此函数体；
                            ----此命令同step的主要区别是
                                --->step遇到用户自定义的函数，将步进到函数中去运行
                                --->而next则直接调用函数，不会进入到函数体内
                        ||  step
                            ----简写s
                            ----单步调试，如果有函数调用，则进入函数
                            ----与命令n不同，n是不进入调用的函数的
                        ||  until
                            ----当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。
                        ||  until+行号
                            ----运行至某行，不仅仅用来跳出循环
                        ||  finish
                            ----运行程序，直到当前函数完成返回
                            ----并打印函数返回时的堆栈地址和返回值及参数值等信息。
                        ||  call 函数(参数)
                            ----调用程序中可见的函数，并传递“参数”
                            ----如:call gdb_test(55)
                        ||  quit
                            ----简记为q，退出gdb
                    2)设置断点
                        ||  break n 
                            ----简写b n
                            ----在第n行处设置断点
                            ----可以带上代码路径和代码名称: b OAGUPDATE.cpp:578
                        ||  b line-or-function if a＞b
                            ----条件断点设置；
                        ||  break func
                            ----break缩写为b
                            ----在函数func()的入口处设置断点，如:break cb_button；
                        ||  delete 断点号n
                            ----删除第n个断点；
                        ||  disable 断点号n
                            ----暂停第n个断点；
                        ||  enable 断点号n
                            ----开启第n个断点；
                        ||  clear 行号n
                            ----清除第n行的断点；
                        ||  info b (info breakpoints)
                            ----显示当前程序的断点设置情况；
                        ||  delete breakpoints
                            ----清除所有断点；
                    3)查看源代码
                        ||  list 
                            ----简记为 l
                            ----其作用就是列出程序的源代码，默认每次显示10行；
                        ||  list 行号
                            ----将显示当前文件以“行号”为中心的前后10行代码
                            ----如:list 12；
                        ||  list 函数名
                            ----将显示“函数名”所在函数的源代码
                            ----如:list main；
                        ||  list :不带参数
                            ----将接着上一次 list 命令的地方输出下边的内容。
                    4)打印表达式
                        ||  print 表达式
                            ----简记为 p 
                            ----其中“表达式”可以是任何当前正在被测试程序的有效表达式
                            ----比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用；
                        ||  print a
                            ----将显示整数 a 的值；
                        ||  print ++a
                            ----将把 a 中的值加1,并显示出来；
                        ||  print name
                            ----将显示字符串 name 的值；
                        ||  print gdb_test(22)
                            ----将以整数22作为参数调用 gdb_test() 函数；
                        ||  print gdb_test(a)
                            ----将以变量 a 作为参数调用 gdb_test() 函数；
                        ||  display 表达式
                            ----在单步运行时将非常有用
                            ----使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值
                            ----如: display a；
                        ||  watch 表达式
                            ----设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序
                            ----如: watch a；
                        ||  whatis 
                            ----查询变量或函数；
                        ||  info function
                            ---- 查询函数；
                        ||  扩展info locals
                            ---- 显示当前堆栈页的所有变量；
                    5)查询运行信息
                        ||  where/bt 
                            ----当前运行的堆栈列表；
                        ||  bt backtrace
                            ----显示当前调用堆栈；
                        ||  up/down
                            ----改变堆栈显示的深度；
                        ||  set args 参数
                            ----指定运行时的参数；
                        ||  show args
                            ----查看设置好的参数；
                        ||  info program
                            ----来查看程序的是否在运行，进程号，被暂停的原因。
                    6)分割窗口
                        ||  layout
                            ----用于分割窗口，可以一边查看代码，一边测试:
                        ||  layout src
                            ----显示源代码窗口；
                        ||  layout asm
                            ----显示反汇编窗口；
                        ||  layout regs
                            ----显示源代码/反汇编和CPU寄存器窗口；
                        ||  layout split
                            ----显示源代码和反汇编窗口；
                        ||  Ctrl + L
                            ----刷新窗口
    ➢Linux 工程管理软件----make
        1)make概述
            ----GNU make是一种代码维护工具
                --->make工具会根据makefile文件定义的规则和步骤，完成整个软件项目的代码维护工作。
                --->一般用来简化编译工作，可以极大地提高软件开发的效率。
                --->windows下一般由集成开发环境自动生成
                --->linux下需要由我们按照其语法自己编写
            ----Make主要解决两个问题
                1)大量代码的关系维护
                    ----大项目中源代码比较多，手工维护、编译时间长而且编译命令复杂，难以记忆及维护
                    ----把代码维护命令及编译命令写在makefile文件中，然后再用make工具解析此文件自动执行相应命令，可实现代码的合理编译
                2)减少重复编译时间
                    ----在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有的目标文件，节省编译时间
        2)makefile语法
            ----语法格式
                ||
                ||  目标:依赖文件列表 
                ||  <Tab>命令列表
                ||
                ----目标
                    --->通常是要产生的文件名称,目标可以是可执行文件或其它obj文件,也可是一个动作的名称
                ----依赖文件
                    --->是用来输入从而产生目标的文件一个目标通常有几个依赖文件(可以没有)
                ----命令
                    --->make执行的动作,一个规则可以含几个命令(可以没有)
                    --->有多个命令时，每个命令占一行
            ----例1:简单的Makefile实例
                --->E:\学习笔记\其他资料\Linux\Image\例1:简单的Makefile实例.jpg
        3)make命令
            ----make命令格式
                ||
                ||  make [ -f file ] [ options ] [ targets ]
                ||
                ----[ -f file ]
                    --->make默认在工作目录中寻找名为GUNmakefile、makefile 、Makefile的文件作为makefile输入文件
                    --->-f可以指定以上名字以外的文件作为makefile输入文件
                ----[ options ]
                    --->执行参数:辅助makefile执行，我们最后介绍
                ----[ targets ]
                    --->若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个目标，然后退出
                    --->指定了make工具要实现的目标，目标可以是一个或多个(多个目标间用空格隔开)
            ----例2:稍复杂的Makefile实例
                --->E:\学习笔记\其他资料\Linux\Image\稍复杂的Makefile实例_1.jpg
                --->E:\学习笔记\其他资料\Linux\Image\稍复杂的Makefile实例_2.jpg
            ----假想目标
                --->前面makefile中出现的文件称之为假想目标
                    1)假想目标并不是一个真正的文件名,通常是一个目标集合或者动作
                    2)可以没有依赖或者命令
                    3)一般需要显示的使用make+名字显示调用
                        ||
                        ||all:exec1 exec2 
                        ||clean:
                        ||(Tab)rm *.o exec
        4)makefile变量
            ----makefile变量类似于C语言中的宏，当makefile被make工具解析时，其中的变量会被展开
            ----变量的作用
                --->保存文件名列表
                --->保存文件目录列表
                --->保存编译器名
                --->保存编译参数
                --->保存编译的输出
                --->...
            ----makefile的变量分类
                --->自定义变量
                    -->在makefile文件中定义的变量。
                    -->make工具传给makefile的变量
                --->系统环境变量
                    -->make工具解析makefile前，读取系统环境变量并设置为makefile的变量。
                --->预定义变量(自动变量)
            ----自定义变量语法
                ||  
                ||  定义变量:变量名=变量值
                ||  引用变量:$(变量名)或${变量名}
                ||
                ----makefile的变量名
                    --->makefile变量名可以以数字开头
                ----变量是大小写敏感的
                ----变量一般都在makefile的头部定义
                ----变量几乎可在makefile的任何地方使用
            ----例子:修改例2中的makefile，使用自定义变量使 其更加通用。
                --->E:\学习笔记\其他资料\Linux\Image\例2_2.jpg
            ----make工具传给makefile的变量
                --->执行make命令时，make的参数options也可以给makefile设置变量。
                --->#make cc=g++
                --->E:\学习笔记\其他资料\Linux\Image\makefile设置变量.jpg
            ----系统环境变量
                --->make工具会拷贝系统的环境变量并将其设置为makefile的变量
                --->在makefile中可直接读取或修改拷贝后的变量
                --->例子:E:\学习笔记\其他资料\Linux\Image\系统环境变量.jpg
            ----预定义变量
                --->makefile中有许多预定义变量，这些变量具有特殊的含义，可在makefile中直接使用
                    -->$@       目标名[[※]]
                    -->$*       目标名中除含扩展名的部分
                        ->扩展名包括:S、s、C、c、cc、cp、cpp、o、a等
                    -->$<       依赖文件列表中的第一个文件[[※]]
                    -->$^       依赖文件列表中除去重复文件的部分[[※]]
                    -->$+       依赖文件列表中所有的文件
                    -->$?       依赖文件列表中比目标文件新的文件
                    -->CC       C编译器的名称，默认值为gcc[[※]]
                    -->其他     E:\学习笔记\其他资料\Linux\Image\makefile预定义变量.jpg
                --->例子:E:\学习笔记\其他资料\Linux\Image\makefile预定义变量_例子.jpg
            ----[ options ]的含义
                    --->-v:显示make工具的版本信息
                    --->-w:在处理makefile之前和之后显示工作路径
                    --->-C dir:读取makefile之前改变工作路径至dir目录
                    --->-n:只打印要执行的命令但不执行
                    --->-s:执行但不显示执行的命令
        5)make补充
            ----.PHONY:clean
            ----makefile通用写法补充
                ||      src=hello.c
                ||      obj=$(src:%.c=%.o)
                ||      main:$(obj)
                ||      	echo $(obj)
                ||      	echo $(\n)
                ||      	gcc $^ -o main
                ||      %.o:%.c
                ||      	gcc -c $< -o $@
                ||      clean:
                ||      	rm *.o *.i *.s main
                ||      .PHONY:clean	
            ----赋值运算符
                ||      VARIABLE = value
                ||      # 在执行时扩展，允许递归扩展。
                ||      VARIABLE := value
                ||      # 在定义时扩展。
                ||      VARIABLE ?= value
                ||      # 只有在该变量为空时才设置值。
                ||      VARIABLE += value
                ||      # 将值追加到变量的尾端。
第四章  系统调用与标准I/O库
    ➢系统调用概述
        1)系统调用与内核
            ----类UNIX系统的软件层次
                --->E:\学习笔记\其他资料\Linux\Image\类UNIX系统的软件层次.jpg
        2)系统调用概述
            ----概述
                --->统调用是操作系统提供给用户程序的一组“特殊” 接口
                --->Linux的不同版本提供了两三百个系统调用。
                --->用户程序可以通过这组接口获得操作系统(内核)提供的服务。
                --->例如:
                    -->用户可以通过文件系统相关的系统调用，请求系统打开文件、关闭文件或读写文件。
                --->E:\学习笔记\其他资料\Linux\Image\操作系统的功能.jpg
                ----系统调用按照功能逻辑大致可分为:
                    --->进程控制
                    --->进程间通信
                    --->文件系统控制
                    --->系统控制
                    --->内存管理
                    --->网络管理
                    --->socket控制
                    --->用户管理
                ----系统调用通常通过函数进行调用
                ----系统调用的返回值
                    --->通常，用一个负的返回值来表明错误，返回一个0值表明成功。
                    --->错误信息存放在全局变量errno中，用户可用perror函数打印出错信息。
                ----系统调用遵循的规范
                    --->在Linux中，应用程序编程接口(API)遵循POSIX标准
                        -->POSIX标准描述了操作系统的函数接口规范(函数名、返回值、参数等)。
                        -->不同操作系统下编写的程序只要遵循POSIX标准，程序都可以直接移植。
                        -->如:
                            ->linux下写的open、write 、read可以直接移植到 unix操作系统下。
    ➢系统调用I/O函数
        ----系统调用中操作I/O的函数，都是针对文件描述符的。
            --->通过文件描述符可以直接对相应的文件进行操作。
            --->如
                -->open、close、write 、read、ioctl
        ----文件描述符
            --->文件描述符是非负整数。
            --->打开现存文件或新建文件时，系统(内核)会返回一个文件描述符。
            --->文件描述符用来指定已打开的文件。
                ||define STDIN_FILENO 0 //标准输入的文件描述符
                ||define STDOUT_FILENO 1 //标准输出的文件描述符
                ||define STDERR_FILENO 2 //标准错误的文件描述符
                    ----程序运行起来后这三个文件描述符是默认打开的。
        ----open函数:打开一个文件
            ||  
            ||  #include <sys/types.h>      //定义新的数据类型
            ||  #include <sys/stat.h>       //文件信息结构体的定义
            ||  #include <fcntl.h>          //声明系统调用、
            ||  int open(const char *pathname, int flags); 
            ||  或
            ||  int open(const char *pathname, int flags, mode_t mode);
            ||
            ||      例:open("/home/.../text",O_RDONLY)
            ||          或:char *p="/home/.../text";
            ||          open(p，O_RDONLY);
            ----参数
                --->pathname:文件的路径及文件名。
                --->flags:open函数的行为标志。 //以什么方式打开
                --->mode:文件权限(可读、可写、可执行)的设置。
            ----返回值
                --->成功返回打开的文件描述符。
                --->失败返回-1，可以利用perror去查看原因
            ----flags的取值及其含义
                --->E:\学习笔记\其他资料\Linux\Image\flags的取值及其含义.jpg
            ----mode的取值及其含义
                --->E:\学习笔记\其他资料\Linux\Image\mode的取值及其含义.jpg
        ----close函数:关闭一个文件
            ||#include <unistd.h>
            ||int close(int fd);
            ----参数
                --->fd是调用open打开文件返回的文件描述符
            ----返回值
                --->成功返回0。
                --->失败返回-1，可以利用perror去查看原因
        ----write函数:把指定数目的数据写到文件
            ||#include <unistd.h>
            ||ssize_t write(int fd, const void *addr, size_t count);
            ----参数
                --->fd:文件描述符
                --->addr:数据首地址
                --->count:写入数据的字节个数
            ----返回值
                --->成功返回实际写入数据的字节个数。
                --->失败返回-1，可以利用perror去查看原因
        ----read函数:把指定数目的数据读到内存
            ||#include <unistd.h>
            ||ssize_t read(int fd, void *addr, size_t count);
            ----参数
                --->fd:文件描述符
                --->addr:内存首地址。
                --->count:读取的字节个数。
            ----返回值
                --->成功返回实际读取到的字节个数。
                --->失败返回-1，可以利用perror去查看原因
        ----scanf()函数在使用中出现的问题
            --->问题描述:  scanf()函数在运行时，会创建一个缓冲区，将输入的内容放进去，然后再输入到相应位置
                            所以在面对输入并且判断的时候，容易直接读缓存区并且跳过输入的过程
            --->问题解决方法
                -->Windows下
                    --fflush(stdin);//清空缓存区
                -->Linux下
                    --方法一
                        ||  setbuf(stdin,NULL);
                        ||  setbuf("%c",&cmd)；
                        ----直接不要缓存区了，选择键盘输入并判断，但是Linux还是不能很好地支持
                    --方法二:以一切皆文件的方式键盘输入
                        ||read(0,buf,sizeof(buf))

    ➢系统调用与内核
        ----为了更好地保护了内核，在Linux中，把程序运行空间分为内核空间和用户空间，它们分别运行在不同的级别上
        ----用户进程在通常情况下不允许访问内核数据，也无法使用内核函数
        ----但在有些情况下，用户空间的进程需要获得一定的系统服务，这时，就必须通过系统调用。
        ----系统调用与内核
            --->E:\学习笔记\其他资料\Linux\Image\系统调用与内核.jpg
        ----应用程序运行在用户空间，系统调用需要切换到内核空间，应用程序应该以某种方式通知内核需要切换到内核空间。
        ----通知内核的机制是靠软件中断实现的:
            --->应用程序执行异常指令，引发一个异常，程序进入中断，系统切换到内核态去执行异常处理程序。
            --->此处的异常处理程序即系统调用处理程序[[syscall()]]。
        ----所有的系统调用陷入内核的方式都一样，所以仅仅是陷入内核空间是不够的。必须以某种方式通知内核进入异常的原因。
        ----Unix系统通过系统调用号通知内核进入异常的原因。
        ----系统调用号
            --->操作系统给每个系统调用分配了一个唯一的编号，这个编号就是系统调用号。
            --->用户空间进程执行一个系统调用时，这个系统调用号就被用来指明执行哪个系统调用。
            --->系统调用号相当关键，一旦分配就不能再有任何变更，否则编译好的应用程序会崩溃。此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用。
        ----路径
            --->/usr/include/i386-linux-gnu/asm/unistd_32.h
            --->E:\学习笔记\其他资料\Linux\Image\系统调用号.jpg
        ----调用系统调用处理程序以执行一个系统调用
            --->E:\学习笔记\其他资料\Linux\Image\调用系统调用处理程序以执行一个系统调用.jpg
    ➢系统调用与库
        ----库函数由两类函数组成
            --->不需要调用系统调用
                    -->不需要切换到内核空间即可完成函数全部功能，
                    -->并且将结果反馈给应用程序
                    -->如strcpy、bzero等字符串操作函数。
            --->需要调用系统调用
                    -->需要切换到内核空间
                    -->这类函数通过封装系统调用去实现相应功能
                    -->如printf、fread等
        ----库函数与系统调用的关系
            --->并不是所有的系统调用都被封装成了库函数，系统提供的很多功能都必须通过系统调用才能实现。
            --->E:\学习笔记\其他资料\Linux\Image\库函数与系统调用的关系.jpg
        ----应用程序调用printf函数时，函数执行的过程
            --->E:\学习笔记\其他资料\Linux\Image\应用程序调用printf函数时，函数执行的过程:.jpg
    ➢标准I/O库函数
        1)概述
            ----无论是编写系统程序还是应用程序，都离不开I/O这个重要的环节。
            ----相对于低级的I/O操作(即系统调用级的I/O)，标准I/O库函数处理了很多细节，如缓存分配等。
            ----考虑到代码的可移植性，开发人员应该在编写代码时尽可能使用标准库函数。
        2)I/O的管理分类
            ----由ANSI标准提供的标准IO库函数
                --->几乎被所有的操作系统支持，如winsdows下编写的程序几乎不用做任何修改就可以在linux下重新编译运行。
                --->如:fopen、fread、fwrite、fclose
            ----以系统调用的方式给用户提供函数接口(遵循POSIX标准)
                --->例如linux操作系统提供的文件IO接口。
                --->如:open、close、read、write、ioctl
                --->系统调用与操作系统直接相关，直接使用系统调用编写的程序的可移植性差。
            ----头文件<stdio.h>中声明了标准C的I/O库，标准C的I/O库在所有通用计算机上的C语言实现都是相同的。
            ----对于标准I/O操作函数来说，打开或创建一个文件的时候，会返回一个指向FILE结构体的指针。
                --->FILE结构体包含了I/O函数库为管理文件所需要的尽可能多的信息。包括了用于I/O文件的文件描述符、指向流缓存的指针、缓存长度等。
                --->定义路径:/usr/include/libio.h
                --->别名(typedef):/usr/include/stdio.h
        3)打开流
            ----头文件: #include <stdio.h>
            ----定义函数
                ||FILE* fopen(const char *pathname, const char *mode);
                    ----函数说明
                        --->pathname: 文件的路径及文件名
                        --->mode: 流的打开方式
                            -->E:\学习笔记\其他资料\Linux\Image\mode.jpg
                    ----返回值
                        --->成功:返回指向该流的指针
                        --->失败:则返回NULL，并把错误代码存在errno中
        4)关闭流
            ----头文件:#include <stdio.h>
            ----定义函数
                ||int fclose(FILE *stream);
                    ----函数说明
                        --->fclose用来关闭fopen打开的文件
                        --->此动作会让缓冲区的数据写入文件中，并释放系统所提供的文件资源。
                    ----返回值
                        --->成功返回0
                        --->失败返回EOF，并把错误代码存到errno中
        5)读、写流
            ----打开了流后，对其进行读写操作的方法
                --->每次一个字符
                    ||  int getchar(void);
                    ||  int getc(FILE *stream);
                    ||  int fgetc(FILE *stream);
                    ||  int putchar(int c);
                    ||  int putc(int c, FILE *stream);
                    ||  int fputc(int c, FILE *stream);
                --->每次一行字符
                    -->输入
                        ||  char *gets(char *buf);
                        ||  char *fgets(char *buf, int n, FILE *stream);
                        ----fgets从stream指定的文件中最多读取 n-1 个字符放到buf所指向的数组中。
                        ----读到换行符或文件结束符后不再向后读，最后一个字符读入后接着写入一个空字符
                        ----返回值
                            --->成功返回buf；失败返回NULL
                        ----注意
                            --->gets()丢掉输入里的换行符
                            --->fgets()存储输入中的换行符
                    -->输出
                        ||  int puts(const char *str);
                        ||  int fputs(const char *str, FILE *stream);
                        ----fputs函数将字符串写入stream指定的文件中，终止字符串的空字符不写入
                            --->成功返回非负数；失败返回EOF
                        ----注意
                            --->puts()为输出添加换行符
                            --->fputs()不为输出添加换行符
                --->每次一个数据块
                    ||size_t fread(void *ptr, size_t size, size_t nobj, FILE *stream);
                    ||size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream);
                    ----size是数据块大小
                    ----nobj指要读取或写入的数据块个数
                    ----stream指定要操作的数据流
                    ----注意
                        --->两个函数返回的是实际读或写的数据的个数，而不是整个数据的字节数
补充章节    指针如此简单
    1)数据类型
        ----数据类型的本质作用:合理的利用空间
            ||
            ||      void test01()
            ||      {
            ||          //基本类型 char short int long float double
            ||          //char 占1字节空间
            ||          char ch;
            ||          //从内存中找到一字节的空间并占用
            ||          printf("sizeof(ch)=%d\n",sizeof(ch));//1字节
            ||          int sh;
            ||          printf("sizeof(sh)=%d\n",sizeof(sh));//2字节
            ||          int num;
            ||          printf("sizeof(num)=%d\n",sizeof(num));//4字节
            ||      }
            ||
            ---- 1B = 8 bit
                --->1b只能存放0或1
    2)指针与内存那些事
        ----内部存贮器:暂存程序数据——掉电丢失
        ----内存两个概念:物理存储器和存储地址空间
            --->物理存储器:实际存在的具体存储器芯片
            --->存储地址空间:对存储器编码的范围[[程序员的关注点⭐]]
        ----内存是沟通CPU与硬盘的桥梁
    3)指针与数琚类型的理解
        ----内存的管理将内存抽象抽象成一个很大的一维字符数组
        ----对内存中的每一个字分配一个32位或64位的编号(与32位或者64位处理器相关)
            --->这个编号我们称之为内存地址
    4)指针变量
        编号(地址):内存中每一个字节分配一个号码
        定义一个变量存放编号号码，这样的变量被称为指针变量
    5)一维数组与指针
        1.定义一个一维数组,数组名是这个数组的《首地址》
            ||
            ||  int a[5]
            ||  //a指向数组的首地址 &a[0]
    6)二维数组与指针
    )实训
        ||
        ||      int num = 100000;
        ||      //指针变量两种类型:自身的类型  指向的类型
        ||      //自身的类型:在指针变量定义的时候，将变量名拖黑，剩下啥类型，指针类型就是啥类型
        ||          //p自身的类型就是int *
        ||      //指向的类型:在指针变量定义的时候，将变量名和离它最近的一个*一起拖黑，剩下啥类型，指针变量指向的就是啥类型
        ||          //*p指向的类型是int
        ||      
        ||      int *p = NULL;
        ||      p = &num;
        ||      //指针变量的跨度
        ||      //指针变量指向的类型的作用:决定了指针变量所取空间内容的宽度 决定了指针变量+1 跳过的单位跨度
        ||      
        ----项目代码
            --->"E:\C语言\cp"
第五章 进程
    ➢进程概述
        ➢进程的定义
            ----程序
                --->程序是存放在存储介质上的一个可执行文件。
            ----进程
                --->进程是程序的执行实例
                --->包括程序计数器、寄存器和变量的当前值
            ----程序是静态的，进程是动态的[[⭐]]
                --->程序是一些指令的有序集合，而进程是程序执行的过程
                --->进程的状态是变化的，其包括进程的创建、调度和消亡
        ➢进程的状态及转换
            ----进程整个生命周期可以简单划分为三种状态:
                --->就绪态
                    -->进程已经具备执行的一切条件，正在等待分配CPU的处理时间
                --->执行态
                    -->该进程正在占用CPU运行
                --->等待态
                    -->进程因不具备某些执行条件而暂时无法继续执行的状态
                --->进程三种状态的转换关系
                    -->"E:\学习笔记\其他资料\Linux\Image\进程三种状态的转换关系.jpg"
        ➢进程控制块
            ----进程控制块(PCB)(Progress Control Block)
                --->OS是根据PCB来对并发执行的进程进行控制和管理的。系统在创建一个进程的时候会开辟一段内存空间存放与此进程相关的PCB数据结构。
                --->PCB是操作系统中最重要的记录型数据结构。PCB中记录了用于描述进程进展情况及控制进程运行所需的全部信息。
                --->PCB是进程存在的唯一标志，在Linux中PCB存放在task_struct结构体中。
    ➢进程控制
        ➢进程号
            ----每个进程都由一个进程号来标识，其类型为pid_t，进程号的范围:0～32767。
            ----进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用了。
            ----在linux系统中进程号由0开始。
                --->进程号为0及1的进程由内核创建
                --->进程号为0的进程通常是调度进程，常被称为交换进程(swapper)。进程号为1的进程通常是init进程。
                --->除调度进程外，在linux下面所有的进程都由进程init进程直接或者间接创建。
            ----进程号(PID)
                --->标识进程的一个非负整型数。
            ----父进程号(PPID)
                --->任何进程(除init进程)都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号(PPID)。
            ----进程组号(PGID)
                --->进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号(PGID)
            ----Linux操作系统提供了三个获得进程号的函数
                --->getpid()
                --->getppid()
                --->getpgid()
                    ||需要包含头文件:
                    ||#include <sys/types.h>
                    ||#include <unistd.h>
                --->pid_t getpid(void)
                    -->返回值:本进程号(PID)
                --->pid_t getppid(void)
                    -->返回值:调用此函数的进程的父进程号(PPID)
                --->pid_t getpgid(pid_t pid)
                    -->参数:0当前PGID，否则为指定进程的PGID
                    -->返回值:进程组号(PGID)
                --->进程实例
                    ||
                    ||      #include <stdio.h>
                    ||      #include <sys/types.h>
                    ||      #include <unistd.h>
                    ||      
                    ||      int main(int argc, char *argv[])
                    ||      {
                    ||      	pid_t pid, ppid, pgid;
                    ||      
                    ||      	pid = getpid();
                    ||      	printf("pid = %d\n", pid);
                    ||      
                    ||      	ppid = getppid();
                    ||      	printf("ppid = %d\n", ppid);
                    ||      
                    ||      	pgid = getpgid(pid);
                    ||      	printf("pgid = %d\n", pgid);
                    ||      	return 0;
                    ||      }
                    ||
        ➢进程的创建
            ----在linux环境下，创建进程的主要方法是调用以下函数
                ||  #include <sys/types.h>
                ||  #include <unistd.h>
                ||  pid_t fork(void);
                    ----fork函数:创建一个新进程
                        ||pid_t fork(void)
                            ----功能
                                --->fork()函数用于从一个已存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。
                            ----返回值
                                --->成功:子进程中返回0，父进程中返回子进程ID
                                --->失败:返回-1
                            ----使用fork函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的"地址空间"
                            ----地址空间包括
                                --->进程上下文
                                --->进程堆栈
                                --->打开的文件描述符
                                --->信号控制设定
                                --->进程优先级
                                --->进程组号等
                            ----子进程所独有的只有它的进程号，计时器等。
                    ----因此， 使用fork函数的代价是很大的。
                        --->fork实例1
                            ||
                            ||      #include <stdio.h>
                            ||      #include <stdlib.h>
                            ||      #include <unistd.h>
                            ||      
                            ||      int main(int argc, char *argv[])
                            ||      {
                            ||      	pid_t pid;//创建变量，保存进程号
                            ||      
                            ||      	pid=fork();//这句话之后，系统中有两个进程实例了
                            ||      	if(pid<0)//如果创建进程失败了
                            ||      		perror("fork");//返回错误信息
                            ||          //创建进程成功
                            ||      	if(pid==0)//子进程中
                            ||      	{
                            ||      		while(1)
                            ||      		{
                            ||      			printf("this is son process\n");
                            ||      			sleep(1);//延时一秒
                            ||      		}
                            ||      	}
                            ||      	else //父进程
                            ||      	{
                            ||      		while(1)
                            ||      		{
                            ||      			printf("this is father process\n");
                            ||      			sleep(1);
                            ||      		}
                            ||      	}
                            ||      	return 0;
                            ||      }
                            ||      
                        --->fork实例2
                            ||
                            ||
                            ||      #include <stdio.h>
                            ||      #include <stdlib.h>
                            ||      #include <unistd.h>
                            ||      
                            ||      int var=10;//全局变量
                            ||      
                            ||      int main(int argc, char *argv[])
                            ||      {
                            ||      	pid_t pid;
                            ||      	int num=9;
                            ||      
                            ||      	pid=fork();//创建一个子进程
                            ||      	if(pid<0)
                            ||      	{
                            ||      		perror("fork");
                            ||      	}
                            ||      	if(pid==0)//是否是子进程
                            ||      	{
                            ||      		var++;
                            ||      		num++;
                            ||      		printf("in son process var=%d,num=%d\n", var, num);
                            ||      	}
                            ||      	else
                            ||      	{
                            ||      		sleep(1);
                            ||      		printf("in father process var=%d,num=%d\n", var, num);
                            ||      	}
                            ||      	printf("common code area\n");
                            ||      	return 0;
                            ||      }
                            ||      
                            ||      
                            ----运行结果
                            ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ ./fork_2 
                            ||      in son process var=11,num=10
                            ||      common code area
                            ||      in father process var=10,num=9
                            ||      common code area
                            ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ 
                            ----fork函数执行结果(复制模式)
                                --->"E:\学习笔记\其他资料\Linux\Image\fork函数执行结果.jpg"
                                    -->从fork_2中可以看出，子进程对变量所做的改变并不影响父进程中该变量的值，说明父子进程各自拥有自己的地址空间
                                    -->一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法
                                    -->如要求父子进程之间相互同步，则要求某种形式的进程间通信。
                        --->fork实例3
                            ||
                            ||
                            ||      #include <stdio.h>
                            ||      #include <stdlib.h>
                            ||      #include <unistd.h>
                            ||      #include <string.h>
                            ||      
                            ||      int main(int argc, char *argv[])
                            ||      {
                            ||      	pid_t pid;//进程号变量
                            ||      	int length = 0;
                            ||      	char buf[] = "a write to stdout\n";//一个标准输出
                            ||      
                            ||      	length = write(1, buf, strlen(buf));//系统调用write()函数
                            ||                                              //参数列表:文件描述符；将要写入的内容，写入内容的长度
                            ||                                              //返回值:实际写入的长度
                            ||      	if(length != strlen(buf))
                            ||      	{
                            ||      		printf("write error\n");
                            ||      	}
                            ||      	printf("before fork\n");
                            ||      	pid=fork();
                            ||      	if(pid<0)
                            ||      	{
                            ||      		perror("fork");
                            ||      	}
                            ||      	else if(pid==0)//子进程
                            ||      	{
                            ||      		printf("in son process\n");
                            ||      	}
                            ||      	else
                            ||      	{
                            ||      		sleep(1);
                            ||      		printf("in father process\n");
                            ||      	}
                            ||      	return 0;
                            ||      }
                            ||      
                            ||
                            ----提示:
                                --->标准I/O提供三种类型的缓冲:
                                    1)全缓冲:(大小不定)
                                        ----在填满标准I/O缓冲区后,才进行实际的I/O操作.
                                        ----术语冲洗缓冲区的意思是进行标准I/O写操作.
                                    2)行缓冲:(大小不定)
                                        ----在遇到"换行符"时,标准I/O库执行I/O操作.
                                        ----这种情况允许我们一次输入一个字符,但只有写了一行后才进行实际的I/O操作.
                                        ----进程的等待
                                    3)不带缓冲
                            ----fork实例3运行结果(1)
                                ||
                                ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ ./fork_3    #//交互:行缓冲
                                ||      a write to stdout
                                ||      before fork
                                ||      in son process
                                ||      in father process
                                ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ 
                                ||      
                            ----fork实例3运行结果(2)
                                ||
                                ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ ./fork_3 > test.txt  #//交互:全缓冲
                                ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ cat test.txt 
                                ||      a write to stdout
                                ||      before fork
                                ||      in son process
                                ||      before fork     #这里出现了一些有趣的东西
                                ||      in father process
                                ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ 
                                ||     #其实这里应该是出现了两个缓冲区，在程序要退出时，两个缓冲区按照退出的先后，分别讲保存的内容放入到指定地方
                                ----行缓冲时:遇到换行符会进行冲洗缓冲区 
                                ----全缓冲时:只有写满了缓冲区或者程序要退出时，才会进行冲洗缓冲区操作
                                ----调用fork函数后,父进程打开的文件描述符都被复制到子进程中.在重定向父进程的标准输出时,子进程的标准输出也被重定向.
                                ----write函数是系统调用,不带缓冲
                                ----标准I/O库是带缓冲的,当以交互方式运行程序时,标准I/O库是是行缓冲的,否则它是全缓冲的.
                    ----fork()与vfork()
                        --->fork():创建子进程的函数
                            -->对于fork()而言，创建子进程成功后直接打印出父子进程执行的两条语句
                            -->#这里要特别强调的是:父子进程的调度的顺序是由调度器决定的。
                        --->vfork();也是创建子进程的函数
                            -->vfork()实例代码1
                                ||
                                ||      #include <stdio.h>
                                ||      #include <stdlib.h>
                                ||      #include <unistd.h>
                                ||      int main(int argc, char *argv[])
                                ||      {
                                ||      	pid_t pid;
                                ||      
                                ||      	pid = vfork();
                                ||      	if(pid<0)
                                ||      		perror("vfork");
                                ||      	if(pid==0)
                                ||      	{
                                ||      		int i = 0;
                                ||      		for(i=0;i<5;i++)
                                ||      		{
                                ||      			printf("this is son process\n");
                                ||      			sleep(1);
                                ||      		}
                                ||      		_exit(0);
                                ||      	}
                                ||      	else 
                                ||      	{
                                ||      		while(1)
                                ||      		{
                                ||      			printf("this is father process\n");
                                ||      			sleep(1);
                                ||      		}
                                ||      	}
                                ||      	return 0;
                                ||      }
                                ||      
                                ----运行结果
                                    ||
                                    ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ ./vfork_1 
                                    ||      this is son process
                                    ||      this is son process
                                    ||      this is son process
                                    ||      this is son process
                                    ||      this is son process
                                    ||      this is father process
                                    ||      this is father process
                                    ||      this is father process
                                    ||      ^C
                                    ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ 
                                    ||      
                                ----子进程如果调用了exit(1)；说明子进程结束后调用父进程。
                                ----这里也说明vfork()的一大特点:先调用子进程，等子进程的exit(1)被调用后，再调用父进程
                            -->vfork()实例代码2
                                ||
                                ||      #include <stdio.h>
                                ||      #include <stdlib.h>
                                ||      #include <unistd.h>
                                ||      
                                ||      int var = 10;
                                ||      int main(int argc, char *argv[])
                                ||      {
                                ||      	pid_t pid;
                                ||      	int num = 9;
                                ||      
                                ||      	pid = vfork();
                                ||      	if(pid<0)
                                ||      	{
                                ||      		perror("vfork");
                                ||      	}
                                ||      	if(pid == 0)
                                ||      	{
                                ||      		var++;
                                ||      		num++;
                                ||      		printf("in son process var=%d,num=%d\n", var, num);
                                ||      		_exit(0);
                                ||      	}
                                ||      	else
                                ||      	{
                                ||      		printf("in father process var=%d,num=%d\n", var, num);
                                ||      	}
                                ||      	return 0;
                                ||      }
                                ||   
                                ----运行结果
                                    ||
                                    ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ ./vfork_2
                                    ||      in son process var=11,num=10
                                    ||      in father process var=11,num=10
                                    ||      yyz@yyz-virtual-machine:~/classtxample/pid/03_fork/03_fork$ 
                                    ||      
                                ----当子进程中将g_val的值改变了之后，父进程也随之改变，这一点却是和fork()不一样的
                                ----进而引出vfork()函数的另一大特点:在子进程调用exit之前，它在父进程的空间中运行，也就是说会更改父进程的数据段、栈和堆。
                                ----即父子进程共享代码区和数据区，且地址和内容都是一样的。
        ➢进程的挂起
            ----三种进程状态
                --->僵尸进程(Zombie process)
                    -->父进程未运行结束,已运行结束的子进程
                --->孤儿进程(Orphan Process)
                    -->父进程运行结束,但子进程未运行结束的子进程
                --->守护进程(精灵进程)(Daemon process)
                    -->守护进程是个孤儿进程,它提供系统服务,常常在系统启动时启动,仅在系统关闭时才终止.
                    -->这种进程脱离终端,在后台运行.
            ----进程的挂起
                --->进程在一定的时间内没有任何动作,称为"进程的挂起"
                    ||      #include <unistd. h>
                    ||      unsigned int sleep (unsigned int sec);
                    ----功能:
                        --->进程挂起指定的秒数,直到指定的时间用完或收到信号才解除挂起
                        --->返回值:若进程挂起到sec指定的时间则返回0,若有信号中断则返回剩余秒数
                        --->#注意
                            -->进程挂起指定的秒数后程序并不会立即执行,系统只是将此进程切换到就绪态
        ➢进程的等待
            ----父子进程有时需要简单的进程间同步,如父进程等待子进程的结束
            ----Linux下提供了以下两个等待函数wait()、 waitpid()
                --->需要包含头文件:
                    ||  #include <sys/types.h
                    ||  #include <sys/wait. h>
                --->pid-t wait(int *status)
                    -->功能:
                        --等待子进程改变状态,如果子进程终止了,此函数会回收子进程的资源.
                        --调用wait函数的进程会挂起,直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒
                        --若调用进程没有子进程或它的子进程已经结束该函数立即返回
                    -->参数:
                        --函数返回时,参数 status中包含子进程退出时的状态信息.
                        --子进程的退出信息在一个int中包含了多个字段,用宏定义可以取出其中的每个字段
                    -->返回值:
                        --如果执行成功则返回子进程的进程号
                        --出错返回-1,失败原因存于 errno中
                    -->取出子进程的退出信息
                        --WIFEXITED (status)
                            ->如果子进程是正常终止的,取出的字段值非零
                        --WEXITSTATUS (status)
                            ->取出的字段值为子进程调用exit函数返回的值(8~16位).在用此宏前应先用宏 WIFEXITED判断子进程是否正常退出,正常退出才可以使用此宏
                    -->wait()函数实例
                        ||
                        ||      #include <stdio.h>
                        ||      #include <stdlib.h>
                        ||      #include <unistd.h>
                        ||      #include <sys/types.h>
                        ||      #include <sys/wait.h>
                        ||      
                        ||      int main(int argc, char *argv[])
                        ||      {
                        ||      	pid_t pid;
                        ||      
                        ||      	pid=fork();
                        ||      	if(pid<0)
                        ||      		perror("fork");
                        ||      	if(pid==0)
                        ||      	{
                        ||      		int i = 0;
                        ||      		for(i=0;i<5;i++)
                        ||      		{
                        ||      			printf("this is son process\n");
                        ||      			sleep(1);
                        ||      		}
                        ||      		_exit(2);
                        ||      	}
                        ||      	else 
                        ||      	{
                        ||      		int status = 0;
                        ||      
                        ||      		wait(&status);
                        ||      		if(WIFEXITED(status)!=0)
                        ||      		{
                        ||      			printf("son process return %d\n", WEXITSTATUS(status));
                        ||      		}
                        ||      		printf("this is father process\n");	
                        ||      	}
                        ||      	return 0;
                        ||      }
                        ||      
                --->pid_t waitpid(pid_t pid, int *status, int options)；
                    -->功能:
                        --等待子进程改变状态,如果子进程终止了,此函数会回收子进程的资源.
                    -->返回值:
                        --如果执行成功则返回子进程ID
                        --出错返回-1,失败原因存于 errno中
                    -->参数pid的值有以下几种类型:
                        --pid>0
                            ->等待进程ID等于pid的子进程
                        --pid=0
                            ->等待同一个进程组中的任何子进程,如果子进程已经加入了别的进程组, waitpid不会等待它
                        --pid=-1
                            ->等待任一子进程,此时waitpid和wait作用一样.
                        --pid<-1:等待指定进程组中的任何子进程,这个进程组的ID等于pid的绝对值.
                    -->status参数中包含子进程退出时的状态信息.
                    -->options参数能进一步控制waitpid的操作
                        --0
                            ->同wait,阻塞父进程,等待子进程退出
                        --WNOHANG
                            ->没有任何已经结束的子进程,则立即返回
                        --WUNTRACED
                            ->如果子进程已暂停则马上返回,且子进程的结束状态不予以理会
                    -->返回值
                        --如果设置了选项WNOHANG,调用waitpid时若没有任何已经结束的子进程可收集,返回0;若有已经结束的子进程可收集,则返回子进程进程号
                        --出错返回-1(当pid所指示的子进程不存在,或此进程存在,但不是调用进程的子进程, waitpid就会出错返回);这时 errno被设置为ECHILD.
                    -->waitpid()函数实例
                        ||
                        ||      #include <stdio.h>
                        ||      #include <stdlib.h>
                        ||      #include <unistd.h>
                        ||      #include <sys/types.h>
                        ||      #include <sys/wait.h>
                        ||      
                        ||      int main(int argc, char *argv[])
                        ||      {
                        ||      	pid_t pid;
                        ||      
                        ||      	pid=fork();
                        ||      	if(pid < 0)
                        ||      		perror("fork");
                        ||      	if(pid == 0)
                        ||      	{
                        ||      		int i = 0;
                        ||      		for(i=0;i<5;i++)
                        ||      		{
                        ||      			printf("this is son process\n");
                        ||      			sleep(1);
                        ||      		}
                        ||      		_exit(2);
                        ||      	}
                        ||      	else 
                        ||      	{		
                        ||      		waitpid(pid, NULL, 0);
                        ||      		printf("this is father process\n");	
                        ||      	}
                        ||      	return 0;
                        ||      }
                        ||      
        ➢进程的终止
            ----在Linux下可以通过以下方式结束正在运行的进程:
                --->void exit (int value)
                --->void _exit(int value)
            ----exit函数:结束进程执行
                --->#include <unistd. h>
                --->void exit(int value)
                --->参数
                    -->status:返回给父进程的参数(低8位有效).
            ----_exit函数:结束进程执行
                --->#include <unistd. h>
                --->void _exit(int value)
                --->参数
                    -->status:返回给父进程的参数(低8位有效).
            ----exit和_exit函数的区别
                --->exit为库函数,而-exit为系统调用
                --->"E:\学习笔记\其他资料\Linux\Image\exit和_exit的区别.jpg"
            ----进程在退出时可以用atexit函数注册退出处理函数
                ||      #include <stdlib. h>
                ||      int atexit(void (*function)(void))
                --->功能
                    --> 注册进程正常结束前调用的函数.
                --->参数
                    --> function:进程结束前,调用函数的入口地址
                --->一个进程中可以多次调用 atexIt函数注册清理函数
                --->正常结束前调用函数的顺序和注册时的顺序相反
            ----atexit()函数实例
                ||
                ||      #include <stdio.h>
                ||      #include <stdlib.h>
                ||      #include <unistd.h>
                ||      
                ||      void clear_fun1(void)
                ||      {
                ||      	printf("perform clear fun1 \n");
                ||      }
                ||      
                ||      void clear_fun2(void)
                ||      {
                ||      	printf("perform clear fun2 \n");
                ||      }
                ||      
                ||      void clear_fun3(void)
                ||      {
                ||      	printf("perform clear fun3 \n");
                ||      }
                ||      
                ||      int main(int argc, char *argv[])
                ||      {
                ||      	atexit(clear_fun1);
                ||      	atexit(clear_fun2);
                ||      	atexit(clear_fun3);
                ||      	printf("process exit 3 sec later!!!\n");
                ||      	sleep(3);
                ||      	return 0;
                ||      }
                ||      
        ➢进程的替换
第六章 管道、命名管道
    ➢进程间通信概述
        1)进程间通信(IPC: Inter Processes Communication)
            ----进程是一个独立的资源分配单元,不同进程(这里所说的进程通常指的是用户进程)之间的资源是独立的,没有关联,不能在一个进程中直接访问另一个进程的资源(例如打开的文件描述符).
            ----进程不是孤立的,不同的进程需要进行信息的交互和状态的传递等,因此需要进程间通信.
        2)进程间通信功能
            ----数据传输:一个进程需要将它的数据发送给另一个进程.
            ----资源共享:多个进程之间共享同样的资源.
            ----通知事件:一个进程需要向另一个或一组进程发送消息,通知它们发生了某种事件
            ----进程控制:有些进程希望完全控制另一个进程的执行(如Debυug进程),此时控制进程希望能够拦截另一个进程的所有操作,并能够及时知道它的状态改变
        3)linux进程间通信(IPC)由以下几个部分发展而来
            ----最初的UNIX进程间通信
            ----SYSTEM V进程间通信
            ----P0SIX进程间通信(P0SIX: Portable Operating System interface可移植操作系统接口)
            ----Socket进程间通信
        4)Linux把优势都继承了下来并形成了自己的IPC
        5)Linux操作系统支持的主要进程间通信的通信机制
            ----"E:\学习笔记\其他资料\Linux\Image\Linux操作系统支持的主要进程间通信的通信机制.jpg"
    ➢管道(pipe)
        1)管道(pipe)又称无名管道。
            ----无名管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。
            ----"E:\学习笔记\其他资料\Linux\Image\无名管道pipe.jpg"
        2)管道是最古老的UNIX IPC方式,其"特点"是
            ----半双工,数据在同一时刻只能在一个方向上流动.
            ----##管道不是普通的文件,不属于某个文件系统,其只存在于内存中##.
            ----管道没有名字,只能在具有公共祖先的进程之间使用
            ----管道的缓冲区是有限的.管道是一个固定大小的缓冲区.在 Linux中,该缓冲区的大小为4 Kbyte.
            ----管道所传送的数据是"无格式"的,这要求管道的读出方与写入方必须事先约定好数据的格式,如多少字节算个消息等.
            ----数据只能从管道的一端写入,从另一端读出
            ----##从管道读数据是一次性操作,数据一旦被读走,它就从管道中被拋弃,释放空间以便写更多的数据.##
        3)管道的函数
            ||
            ||      #include <unistd.h> 
            ||      int pipe(int filedes[2]);
            ----功能:经由参数 filedes返回两个文件描述符
            ----参数
                --->filedes为int型数组的首地址,其存放了管道的文件描述符fd[0]、fd[1]
                --->filedes[0]为读而打开, filedes[1]为写而打开管道, filedes[0]的输出是 filedes[1]的输入.
            ----返回值
                --->成功:返回0
                --->失败:返回-1
            ----"E:\学习笔记\其他资料\Linux\Image\父子进程通过管道实现数据的传输.jpg"
            ----pipe()函数实例
                --->源代码
                    ||
                    ||      #include <stdio.h>
                    ||      #include <string.h>
                    ||      #include <unistd.h>
                    ||      #include <stdlib.h>
                    ||      #include <sys/types.h>
                    ||      #include <sys/wait.h>
                    ||      
                    ||      int main(int argc, char *argv[])
                    ||      {
                    ||      	int fd_pipe[2];
                    ||      	char buf[] = "hello12222 world!";
                    ||      	pid_t pid;
                    ||      
                    ||      	if (pipe(fd_pipe) < 0)
                    ||      		perror("pipe");
                    ||      		//创建管道
                    ||      		//--->filedes为int型数组的首地址,其存放了管道的文件描述符fd[0]、fd[1]
                    ||              //--->filedes[0]为读而打开, filedes[1]为写而打开管道, filedes[0]的输出是 filedes[1]的输入.
                    ||      		//成功返回0，失败返回-1
                    ||      		//管道没有名字,只能在具有公共祖先的进程之间使用
                    ||      	pid = fork();//创建子进程
                    ||      	if (pid < 0)
                    ||      	{
                    ||      		perror("fork");
                    ||      		exit(-1);
                    ||      	}
                    ||      	if (pid == 0)
                    ||      	{
                    ||      		write(fd_pipe[1], buf, strlen(buf));
                    ||      		//write(2, buf, strlen(buf));//直接在屏幕上打印buf内的东西
                    ||      		//写入目标文件的文件描述符
                    ||      		//参数:写入的目标文件，写入的内容，写入的长度
                    ||      		_exit(0);
                    ||      	}
                    ||      	else
                    ||      	{
                    ||      		wait(NULL);
                    ||      		printf("这里是父进程！打印输出:\n");
                    ||      		memset(buf, 0, sizeof(buf));
                    ||      		/*
                    ||      			memset是计算机中C/C++语言初始化函数。
                    ||      			作用是将某一块内存中的内容全部设置为指定的值，
                    ||      			这个函数通常为新申请的内存做初始化工作。
                    ||      			void *memset(void *s, int ch, size_t n);
                    ||      			函数解释:将s中当前位置后面的n个字节 (typedef unsigned int size_t )用 ch 替换并返回 s 。
                    ||      		*/
                    ||      		read(fd_pipe[0], buf, sizeof(buf));
                    ||      		//read(1, buf, sizeof(buf));//在屏幕上标准输入，并保存在相应位置
                    ||      		printf("buf=[%s]\n", buf);
                    ||      	}
                    ||      	return 0;
                    ||      }
                    ||      
                    ||      
                    ----运行效果
                    ||      
                    ||      buf=[hello world]
                    ||
        4)文件描述符概述
            ----文件描述符是非负整数,是文件的标识.
            ----内核利用文件描述符( file descriptor)来访问文件
            ----利用open打开一个文件时,内核会返回一个文件描述符
                --->每个进程都有一张文件描述符的表,进程刚被创建时,其计录了默认打开的标准输入、标准输出标准错误输岀三个设备文件的文件描述符0、1、2.
                --->在进程中打开其他文件时,系统会返回文件描述符表中最小可用的文件描述符,并将此文件描述符记录在表中
        5)dup和dup2函数
            ----dup和dup2是两个非常有用的系统调用,都是用来复制一个文件的描述符
                ||      
                ||      int dup(int oldfd);
                ||      int dup2(int oldfd, int newfd);
                ----dup和dup2经常用来重定向进程的stdin、stdout和stderr。
            ----dup函数
                ||
                ||      #include <unistd.h> 
                ||      int dup(int oldfd);
                ||
                ----功能
                    --->复制oldfd文件描述符,并分配一个新的文件描述符,新的文件描述符是调用进程文件描述符表中最小可用的文件描述符.
                ----参数
                    --->oldfd:要复制的文件描述符oldfd
                ----返回值
                    --->成功:新文件描述符.
                    --->失败:返回-1,错误代码存于erno中
                ----注意
                    --->#新的文件描述符和oldfd指向的是同一个文件,共享oldfd所有的锁定、读写位置和各项权限或标志,
                    --->#但文件描述符之间并不共享close-0n-exec标志
            ----dup函数实例1
                ||
                ||      
                ||      #include <stdio.h>
                ||      #include <unistd.h>
                ||      #include <stdlib.h>
                ||      #include <sys/types.h>
                ||      #include <sys/stat.h>
                ||      #include <fcntl.h>
                ||      
                ||      int main(void)
                ||      {
                ||      	int fd1;
                ||      	int fd2;
                ||      
                ||      	fd1 = open("test", O_CREAT | O_WRONLY,0777);
                ||                  //O_CREAT检测是否有这个文件，没有就创建
                ||                  //打开一个文件描述符
                ||                  //fd1 = 3
                ||      	if (fd1 < 0)
                ||      	{
                ||      		perror("open");
                ||      		exit(-1);
                ||      	}
                ||      	close(1);
                ||          //关闭一个文件描述符，这里关闭了标准输出文件描述符
                ||          //此时文件描述表里面的内容为 0，2，3
                ||          //标准输入、标准输出、标准错误输岀三个设备文件的文件描述符0、1、2
                ||          
                ||          
                ||      	fd2 = dup(fd1);
                ||          //fd2 = 1
                ||          //dup函数:复制oldfd文件描述符,并分配一个新的文件描述符
                ||          //新的文件描述符是调用进程文件描述符表中"最小可用"的文件描述符.
                ||      	printf("fd2=%d\n", fd2);
                ||      	return 0;
                ||      }
                ||      
                ----运行效果
                ||
                ||      在文件所在目录下生成test文档，里面记录数据:fd2=1
            ----dup函数实例2
                ||
                ||          
                ||         #include <stdio.h>
                ||         #include <unistd.h>
                ||         #include <stdlib.h>
                ||         #include <sys/types.h>
                ||         #include <sys/stat.h>
                ||         #include <fcntl.h>
                ||         
                ||         int main(int argc, char *argv[])
                ||         {
                ||         	int fd1;
                ||         	int fd2;
                ||         	
                ||         	fd2=dup(1);//save stdout
                ||          //printf标准输出给文件描述符表中序号为1的文件
                ||         	//默认情况下，这个文件是屏幕的标准输出
                ||         	//0,1,2  fd2 = 3
                ||         	
                ||         	printf("new:fd2=%d\n",fd2);
                ||         	
                ||         	fd1=open("test",O_CREAT|O_RDWR, S_IRWXU);
                ||          fd1--->test
                ||         	close(1);
                ||         	
                ||         	// 0   2 fd2 = 3 fd1 = 4
                ||         	//fd2--->stdout  fd1--->test
                ||         	dup(fd1);//1---> test
                ||         	
                ||         	// 0 1--->test 2--->stdin 3--->stdout 4--->test 
                ||         	// 1--->test
                ||         	
                ||         	printf("hello world\n");
                ||          //打印到文件1
                ||         
                ||         	close(1);
                ||          //如果关闭了序号1，即序号1不代表任何文件，printf就没有效果了
                ||         	dup(fd2);//reset 1--->stdout 
                ||         	printf("i love you \n");
                ||         	return 0;
                ||         }
                ||         
                ||       
                ----运行效果  
                ||         yyz@yyz-virtual-machine:~/classtxample/pipe$ ./a.out 
                ||         new:fd2=3
                ||         i love you 
                ||         yyz@yyz-virtual-machine:~/classtxample/pipe$ cat test
                ||         hello world
            ----dup2函数
                ||
                ||      #include <unistd.h>
                ||      int dup2(int oldfd, int newfd)
                ----功能
                    --->复制一份打开的文件描述符oldfd,并分配新的文件描述符newfd,newfd也标识oldfd所标识的文件
                ----注:
                    --->newfd是小于文件描述符最大允许值的非负整数,如果newfd是一个已经打开的文件描述符,则首先关闭该文件,然后再复制.
                ----参数
                    --->要复制的文件描述符oldfd
                    --->分配的新的文件描述符newfd
                ----返回值
                    --->成功:返回newfd
                    --->失败:返回-1，错误代码存于errno中
            ----dup2函数实例
                ||
                ||
                ||      #include <stdio.h>
                ||      #include <unistd.h>
                ||      #include <stdlib.h>
                ||      #include <sys/types.h>
                ||      #include <sys/stat.h>
                ||      #include <fcntl.h>
                ||      
                ||      int main(void)
                ||      {
                ||      	int fd1;
                ||      	int fd2;
                ||      
                ||      	fd1 = open("test", O_CREAT | O_WRONLY, 0666);
                ||          //fd1--->test
                ||      	if (fd1 < 0)
                ||      	{
                ||      		perror("open:");
                ||      		exit(-1);
                ||      	}
                ||          //int dup2(int oldfd, int newfd)
                ||          //复制一份打开的文件描述符oldfd,并分配新的文件描述符newfd,newfd也标识oldfd所标识的文件
                ||          //newfd是小于文件描述符最大允许值的非负整数,如果newfd是一个已经打开的文件描述符,则首先关闭该文件,然后再复制.
                ||          //成功:返回newfd,失败:返回-1
                ||      	fd2 = dup2(fd1, 1);
                ||          // close(1)
                ||          // 1--->test
                ||      	printf("fd2=%d\n", fd2);
                ||      	return 0;
                ||      }
                ||      
                ||      
                ----运行结果
                ||      
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ ./dup2_1 
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ cat test 
                ||      fd2=1
                ||      
            ----dup2函数实例2
                ||
                ||      
                ||      #include <stdio.h>
                ||      #include <unistd.h>
                ||      #include <stdlib.h>
                ||      #include <sys/types.h>
                ||      #include <sys/stat.h>
                ||      #include <fcntl.h>
                ||      
                ||      int main(int argc, char *argv[])
                ||      {
                ||      	int fd1;
                ||      	int fd2 = 3;
                ||      	int err = 0;
                ||      
                ||      	err = dup2(1,fd2);//save 1
                ||          //dup2(1,3)  把1复制，命序为3，返回3
                ||          //err = 3
                ||          
                ||      	if(err<0)
                ||      	{
                ||      		perror("dup2");
                ||      	}
                ||      	printf("fd2=%d,err=%d\n", fd2, err);
                ||      
                ||      
                ||      	fd1 = open("test", O_CREAT|O_RDWR, S_IRWXU);
                ||          //已经使用了 0 1 2 3
                ||          //新建fd1 = 4 
                ||      
                ||      	dup2(fd1,1);//1---> test
                ||      	printf("hello world\n");
                ||          //将1指向test文件，标准输出(到屏幕)保存在fd2和fd1当中    
                ||          //此时打印内容会写进text文件中
                ||      
                ||      	dup2(fd2,1);//reset 1--->stdout 
                ||      	printf("I love you \n");
                ||      	return 0;
                ||      }
                ||      
                ----运行结果
                ||
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ ./dup2_2
                ||      fd2=3,err=3
                ||      I love you 
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ cat test
                ||      hello world
                ||      
    ➢命名管道(FIFO)
        1)命名管道(FIFO)和管道(pipe)基本相同,但也有一些显著的不同,其特点是
            ----FIFO在文件系统中作为一个特殊的文件而存在
            ----虽然FIFO文件存在于文件系统中,但FIFO中的内容却存放在内存中,在Linux中,该缓冲区的大小为4Kbyt
            ----FIFO有名字,不同的进程可以通过该命名管道进行通信
            ----FIFO所传送的数据是无格式的
            ----从FIFO读数据是一次性操作,数据一旦被读,它就从FIFO中被拋弃,释放空间以便写更多的数据
            ----当共享FIFO的进程执行完所有的I/O操作以后,FIFO将继续保存在文件系统中以便以后使用
        2)FIFO文件的创建
            ||      #include <sys/types.h>
            ||      #include <sys/stat.h>
            ||      int mkfifo( const char *pathname, mode_t mode);
            ----参数
                --->pathame:FIFO的路径名+文件名.
                --->mode:mode_t类型的权限描述符
            ----返回值
                --->成功:返回0
                --->失败:如果文件已经存在,则会出错且返回-1
        3)FIFO文件的读写1
            ----因为使用pipe的进程通过继承获得了pipe的文件描述符,所以pipe仅需要创建而不需要打开.
            ----但是FIFO则需要打开,因为使用它们的进程可以没有任何关系
            ----一般文件的I/O函数都可以作用于FIFO,如open close、read、 write等
            ----当打开FIFO时,非阻塞标志(O_NONBLOCK)产生下列影响
                --->不指定O_NONBLOCK(即不写|O_NONBLOCK)
                    -->只读open要阻塞到某个其他进程为写而打开此FIFO
                    -->只写open要阻塞到某个其他进程为读而打开此FIFO.
                --->FIFO函数实例1
                ||
                ||      "read.c"
                ||
                ||      #include <stdio.h>
                ||      #include <string.h>
                ||      #include <unistd.h>
                ||      #include <sys/types.h>
                ||      #include <sys/stat.h>
                ||      #include <fcntl.h>
                ||      
                ||      int main(int argc, char *argv[])
                ||      {
                ||      	int fd;
                ||      	int ret;
                ||      	char recv[100];
                ||      
                ||      	ret = mkfifo("my_fifo", S_IRUSR|S_IWUSR);
                ||      	if(ret != 0)
                ||      	{
                ||      		perror("mkfifo");
                ||      	}
                ||      	printf("before open\n");
                ||      	fd = open("my_fifo", O_RDONLY);
                ||      	if(fd<0)
                ||      	{
                ||      		perror("open fifo");
                ||      	}
                ||      	printf("after open and before read\n");
                ||      	bzero(recv, sizeof(recv));
                ||      	read(fd, recv, sizeof(recv));
                ||      	printf("read from my_fifo buf=[%s]\n",recv);
                ||      	return 0;
                ||      }
                ||      
                ||      "write.c"
                ||
                ||      #include <stdio.h>
                ||      #include <string.h>
                ||      #include <unistd.h>
                ||      #include <sys/types.h>
                ||      #include <sys/stat.h>
                ||      #include <fcntl.h>
                ||      
                ||      int main(int argc, char *argv[])
                ||      {
                ||      	int fd;
                ||      	int ret;
                ||      	char send[100] = "Hello I love you";
                ||      
                ||      	ret = mkfifo("my_fifo", S_IRUSR|S_IWUSR);
                ||      	if(ret != 0)
                ||      	{
                ||      		perror("mkfifo");
                ||      	}
                ||      	printf("before open\n");
                ||      	fd = open("my_fifo", O_WRONLY);
                ||      	if(fd<0)
                ||      	{
                ||      		perror("open fifo");
                ||      	}
                ||      	printf("after open and before read\n");
                ||      	write(fd, send, strlen(send));
                ||      	printf("write to my_fifo buf=%s\n",send);
                ||      	return 0;
                ||      }
                ||      
                ||  
                ----运行结果
                ||
                ||
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ echo 这里是写入端
                ||      这里是写入端
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ gcc 04_fifo_write_1.c -o write
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ ./write 
                ||      mkfifo: File exists
                ||      before open
                ||      after open and before read
                ||      write to my_fifo buf=Hello I love you
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ 
                ||
                ||
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ echo 这里是读出端
                ||      这里是读出端
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ gcc 04_fifo_read_1.c -o read
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ ./read 
                ||      mkfifo: File exists
                ||      before open
                ||      after open and before read
                ||      read from my_fifo buf=[Hello I love you]
                ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ 
                ||     
                --->注
                    -->
        4)FIFO文件的读写2
            ----不指定O_NONBLOCK时，除了只读、只写open会阻塞，调用read函数从FIFO里读数据时read也会阻塞。
                --->通信过程中若写进程先退出了，则调用read函数从FIFO里读数据时不阻塞；
                --->若写进程又重新运行，则调用read函数从FIFO里读数据时又恢复阻塞。 
                --->通信过程中，读进程退出后，写进程向命名管道内写数据时，写进程也会退出
                --->FIFO函数实例2
                    ||
                    ||      read.c
                    ||
                    ||      #include <stdio.h>
                    ||      #include <string.h>
                    ||      #include <unistd.h>
                    ||      #include <sys/types.h>
                    ||      #include <sys/stat.h>
                    ||      #include <fcntl.h>
                    ||      
                    ||      int main(int argc, char *argv[])
                    ||      {
                    ||      	int fd;
                    ||      	int ret;
                    ||      
                    ||      	ret = unlink("my_fifo");	//删除上次运行后残留的fifo
                    ||      	if(ret<0)
                    ||      	{
                    ||      		perror("unlink fifo");
                    ||      	}
                    ||      	ret = mkfifo("my_fifo", S_IRUSR|S_IWUSR);
                    ||      	if(ret != 0)
                    ||      	{
                    ||      		perror("mkfifo");
                    ||      	}
                    ||      	fd = open("my_fifo", O_RDONLY);
                    ||      	if(fd<0)
                    ||      	{
                    ||      		perror("open fifo");
                    ||      	}
                    ||      	while(1)
                    ||      	{
                    ||      		char recv[100];
                    ||      
                    ||      		bzero(recv, sizeof(recv));
                    ||      		read(fd, recv, sizeof(recv));
                    ||      		printf("read from my_fifo buf=[%s]\n",recv);
                    ||      		sleep(1);
                    ||      	}
                    ||      	return 0;
                    ||      }
                    ||      
                    ||
                    ||      write.c
                    ||
                    ||
                    ||      #include <stdio.h>
                    ||      #include <string.h>
                    ||      #include <unistd.h>
                    ||      #include <sys/types.h>
                    ||      #include <sys/stat.h>
                    ||      #include <fcntl.h>
                    ||      
                    ||      int main(int argc, char *argv[])
                    ||      {
                    ||      	int fd;
                    ||      	char send[100] = "Hello I love you";
                    ||      
                    ||      	fd = open("my_fifo", O_WRONLY);
                    ||      	if(fd<0)
                    ||      	{
                    ||      		perror("open fifo");
                    ||      	}
                    ||      	write(fd, send, strlen(send));
                    ||      	printf("write to my_fifo buf=%s\n",send);
                    ||      	while(1);
                    ||      	return 0;
                    ||      }
                    ||   
                    ----运行结果   
        5)FIFO文件的读写3
            ----指定O_NONBLOCK
                --->只读方式打开:如果没有进程已经为写而打开个FIFO,只读open成功,立即返回
                --->只写方式打开:如果没有进程已经为读而打开一个FIFO,那么只写open将出错返回-1
                --->FIFO函数实例2
                    ||   
                    ||      read.c
                    ||   
                    ||   
                    ||      #include <stdio.h>
                    ||      #include <string.h>
                    ||      #include <unistd.h>
                    ||      #include <sys/types.h>
                    ||      #include <sys/stat.h>
                    ||      #include <fcntl.h>
                    ||      
                    ||      int main(int argc, char *argv[])
                    ||      {
                    ||      	int fd;
                    ||      	int ret;
                    ||      
                    ||      	ret = unlink("my_fifo");	//删除上次运行后残留的fifo
                    ||      	if(ret<0)
                    ||      	{
                    ||      		perror("unlink fifo");
                    ||      	}
                    ||      	ret = mkfifo("my_fifo", S_IRUSR|S_IWUSR);
                    ||      	if(ret != 0)
                    ||      	{
                    ||      		perror("mkfifo");
                    ||      	}
                    ||      	fd = open("my_fifo", O_RDONLY|O_NONBLOCK);
                    ||      	if(fd<0)
                    ||      	{
                    ||      		perror("open fifo");
                    ||      	}
                    ||      	while(1)
                    ||      	{
                    ||      		char recv[100];
                    ||      
                    ||      		bzero(recv, sizeof(recv));
                    ||      		read(fd, recv, sizeof(recv));
                    ||      		printf("read from my_fifo buf=[%s]\n",recv);
                    ||      		sleep(1);
                    ||      	}
                    ||      	return 0;
                    ||      }
                    ||      
                    ||   
                    ||      write.c
                    ||      
                    ||      #include <stdio.h>
                    ||      #include <string.h>
                    ||      #include <unistd.h>
                    ||      #include <sys/types.h>
                    ||      #include <sys/stat.h>
                    ||      #include <fcntl.h>
                    ||      
                    ||      int main(int argc, char *argv[])
                    ||      {
                    ||      	int fd;
                    ||      	char send[100] = "Hello I love you";
                    ||      
                    ||      	fd = open("my_fifo", O_WRONLY|O_NONBLOCK);
                    ||      	if(fd<0)
                    ||      	{
                    ||      		perror("open fifo");
                    ||      	}
                    ||      	write(fd, send, strlen(send));
                    ||      	printf("write to my_fifo buf=%s\n",send);
                    ||      	while(1);
                    ||      	return 0;
                    ||      }
                    ||      
                    ----运行结果  
                    ||
                    ||
第七章  消息队列、共享内存
    ➢消息队列(message queue)
        1)消息队列概述
            ----消息队列是消息的链表，存放在内存中，由内核维护
            ----消息队列的特点
                --->消息队列允许一个或多个进程向它写入或者读取消息,并且"每条消息都有类型".
                --->消息队列可以实现消息的"随机查询",消息不一定要以先进先出的次序读取,编程时可以按消息的类型读取.
                --->与无名管道、有名管道一样,从消息队列中读出消息,消息队列中数据"会被删除".
                --->同样消息队列中的消息是有格式的.
            ----只有内核重启或人工删除时,该消息才会被删除,若不人工删除消息队列,"消息队列会一直存在于内存中"
            ----消息队列标识符,用来标识消息队列.消息队列在整个系统中是唯一的.
            ----在Linux操作系统中消息队列限制值如下:
                --->消息队列个数最多为16个
                --->消息队列总容量最多为16384字节
                --->每个消息内容最多为8192字节
            ----System V提供的IPC通信机制需要一个key值,通过key值就可在系统内获得一个唯一的消息队列ID
            ----key值可以是人为指定的,也可以通过ftok函数获得.
        2)消息队列函数
            ----函数
                --->获取IPC键值
                    ||      #include <sys/types.h>
                    ||      #include <sys/ipc. h>
                    ||      key-t ftok(const char *pathname, int proj-id)
                    ----功能
                        --->获得项目相关的唯一的IPC键值。
                    ----参数
                        --->pathname:路径名
                        --->proj_id:项目ID，非0整数(只有低8位有效)
                    ----返回值
                        --->成功返回key值，失败返回 -1
                --->创建消息队列
                    ||      #include <sys/msg.h>
                    ||      int msgget(key_t key, int msgflg)；
                    ----功能
                        --->创建一个新的或打开一个已经存在的消息队列。
                        --->不同的进程调用此函数，只要用相同的key值就能得到同一个消息队列的ID。
                    ----参数
                        --->key:IPC键值
                        --->msgflg:标识函数的行为:IPC_CREAT(创建)或 IPC_EXCL(如果已经存在则返回失败)。
                    ----返回值
                        --->成功:消息队列的标识符，失败:返回-1。
            ----使用shell命令操作消息队列
                --->查看消息队列
                    ||      ipcs -q
                    ||
                    ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ ipcs -q
                    ||      
                    ||      --------- 消息队列 -----------
                    ||      键        msqid      拥有者  权限     已用字节数 消息 
                --->删除消息队列
                    ||      ipcrm -q msqid
                    ||
                    ||      yyz@yyz-virtual-machine:~/classtxample/pipe$ ipcrm -q msqid
                    ||      ipcrm: 解析参数失败: 'msqid'
                    ||      
            ----消息队列的消息的格式
                    ||      typedef struct _msg
                    ||      {
                    ||      
                    ||      long mtype;     /*消息类型*/
                    ||      char mtext[100] /*消息正文*/
                    ||      ...             /*消息的正文可以有多个成员*/
                    ||      }MSG
                    ----消息类型必须是长整型的,而且必须是结构体类型的第一个成员
                    ----类型下面是消息正文,正文可以有多个成员(正文成员可以是任意数据类型的)
            ----发送消息
                ||      #include <sys/msg.h>
                ||      int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
                ----功能
                    --->将新消息添加到消息队列。
                ----参数
                    --->msqid:消息队列的队列ID。
                    --->msgp:待发送消息结构体的地址。
                    --->msgsz:消息正文的字节数。
                    --->msgflg:函数的控制属性
                        -->0:msgsnd调用阻塞直到条件满足为止。
                        -->IPC_NOWAIT: 若消息没有立即发送则调用该函数的进程会立即返回。
                ----返回值
                    --->成功:0；失败:返回-1。
            ----发送消息
                ||      #include <sys/msg.h>
                ||      ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
                ----功能
                    --->从ID为msqid的消息队列中接收一个消息。一旦接收消息成功，则消息在消息队列中被删除。
                ----参数
                    --->msqid:消息队列的ID，代表要从哪个消息列中获取消息
                    --->msgp: 存放消息结构体的地址
                    --->msgsz:消息正文的字节数。
                    --->msgtyp:消息的类型、可以有以下几种类型
                        -->msgtyp = 0:返回队列中的第一个消息
                        -->msgtyp > 0:返回队列中消息类型为msgtyp的消息
                        -->msgtyp < 0:返回队列中消息类型值小于或等于msgtyp绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。
                        -->注意:
                            --若消息队列中有多种类型的消息，msgrcv获取消息的时候按消息类型获取，而不是先进先出的模式。
                            --在获取某类型消息的时，若队列中有多条此类型的消息，则获取最先添加的消息，即先进先出原则。
                    --->msgflg:函数的控制属性
                        -->0:msgrcv调用阻塞直到接收消息成功为止。
                        -->MSG_NOERROR:若返回的消息字节数比nbytes字节数 多,则消息就会截短到nbytes字节,且不通知消息发送进程
                        -->IPC_NOWAIT:调用进程会立即返回。若没有收到消息则立即返回-1
                ----返回值
                    --->成功返回读取消息的长度，失败返回-1
            ----消息队列的控制
                ||      #include <sys/msg.h>
                ||      int msgctl(int msqid, int cmd, struct msqid_ds *buf);
                ----功能
                    --->对消息队列进行各种控制，如修改消息队列的属性，或删除消息消息队列。
                ----参数
                    --->msqid:消息队列的ID
                    --->cmd:函数功能的控制
                        -->IPC_RMID:删除由msqid指示的消息队列，将它从系统中删除并破坏相关数据结构。
                        -->IPC_STAT:将msqid相关的数据结构中各个元素的当前值存入到由buf指向的结构中。
                        -->IPC_SET:将msqid相关的数据结构中的元素设置为由buf指向的结构中的对应值。
                    --->buf:msqid_ds数据类型的地址，用来存放或更改消息队列的属性。
                ----返回值
                    --->返回值:成功:返回 0；失败:返回 -1
            ----消息队列函数示例
                ||
                ||          write.c
                ||
                ||      #include <stdio.h>
                ||      #include <unistd.h>
                ||      #include <stdlib.h>
                ||      #include <sys/types.h>
                ||      #include <sys/ipc.h>
                ||      #include <sys/msg.h>
                ||      #include <string.h>
                ||      
                ||      typedef struct _msg
                ||      {
                ||      	long mtype;
                ||      	char mtext[50];
                ||      }MSG;
                ||      
                ||      int main(int argc, char *argv[])
                ||      {
                ||      	key_t key;
                ||      	int  msgqid;
                ||      	MSG msg;
                ||      
                ||      	key = ftok(".", 2012);
                ||      	msgqid = msgget(key, IPC_CREAT|0666);
                ||      	if (msgqid == -1)
                ||      	{
                ||      		perror("msgget");
                ||      		exit(-1);
                ||      	}
                ||      	msg.mtype = 10;
                ||      	strcpy(msg.mtext, "hello world");
                ||      	msgsnd(msgqid, &msg, sizeof(msg.mtext), 0);
                ||      	return 0;
                ||      }
                ||
                ||
                ||          read.c
                ||
                ||      #include <stdio.h>
                ||      #include <unistd.h>
                ||      #include <stdlib.h>
                ||      #include <sys/types.h>
                ||      #include <sys/ipc.h>
                ||      #include <sys/msg.h>
                ||      #include <string.h>
                ||      
                ||      typedef struct _msg
                ||      {
                ||      	long mtype;
                ||      	char mtext[50];
                ||      }MSG;
                ||      
                ||      int main(int argc, char *argv[])
                ||      {
                ||      	key_t key;
                ||      	int  msgqid;
                ||      	MSG msg;
                ||      
                ||      	key = ftok(".", 2012);
                ||      	msgqid = msgget(key, IPC_CREAT|0666);
                ||      	if (msgqid == -1)
                ||      	{
                ||      		perror("msgget");
                ||      		exit(-1);
                ||      	}
                ||      	msgrcv(msgqid, &msg, sizeof(msg.mtext), 10, 0);
                ||      	printf("msg.mtext=%s\n", msg.mtext);
                ||      	msgctl(msgqid, IPC_RMID, NULL);
                ||      	return 0;
                ||      }
                ||      
                ----运行效果
                ||
                ||      yyz@yyz-virtual-machine:~/classtxample/05_msg/message_queue$ echo 这里是输入端
                ||      这里是输入端
                ||      yyz@yyz-virtual-machine:~/classtxample/05_msg/message_queue$ gcc 01_message_queue_write.c -o write
                ||      yyz@yyz-virtual-machine:~/classtxample/05_msg/message_queue$ ./write 
                ||      
                ||      yyz@yyz-virtual-machine:~/classtxample/05_msg/message_queue$ echo 这里是读入端
                ||      这里是读入端
                ||      yyz@yyz-virtual-machine:~/classtxample/05_msg/message_queue$ gcc 01_message_queue_read.c -o read
                ||      yyz@yyz-virtual-machine:~/classtxample/05_msg/message_queue$ ./read 
                ||      msg.mtext=hello world
    ➢共享内存(shared memory)
        1)共享内存概述
            ----共享内存允许两个或者多个进程共享给定的存储区域
            ----共享内存是进程间共享数据的一种最快的方法,一个进程向共享的内存区域写入了数据,共享这个内存区域的所有进程就可以立刻看到其中的内容
            ----使用共享内存要注意的是多个进程之间对一个给定存储区访问的互斥.若一个进程正在向共享内存区写数据,则在它做完这一步操作前,别的进程不应当去读、写这些数据.
            ----"E:\学习笔记\其他资料\Linux\Image\共享内存示意图.jpg"
        2)在Linux操作系统中共享内存限制值如下
            ----共享存储段的最大字节数:33554432
            ----共享存储段的最小字节数:1
            ----系统中共享存储段的最大段数:4096
            ----每个进程共享存储段的最大段数:4096
        3)共享内存相关函数
            ----获得一个共享存储标识符
                ||      #include <sys/ipc.h> 
                ||      #include <sys/shm.h>
                ||      int shmget(key_t key, size_t size,intshmflg);
                ----功能
                    --->创建或打开一块共享内存区
                ----参数
                    --->key:IPC键值
                    --->size:该共享存储段的长度(字节)
                    --->shmflg:用来标识函数的行为
                    --->shmflg:用来标识函数的行为
                        -->IPC_CREAT:如果不存在就创建
                        -->IPC_EXCL:如果已经存在则返回失败
                        -->IPC_NOWAIT:调用进程会立即返回。若发生错误 则返回-1。
                    --->SHM_R:可读
                    --->SHM_W:可写
                ----返回值
                    --->成功:返回共享内存标识符。
                    --->失败:返回-1。
            ----使用shell命令操作共享内存:
                --->查看共享内存
                    -->ipcs -m
                --->删除共享内存
                    -->ipcrm -m shmid
            ----共享内存映射(attach)
                ||      #include <sys/ipc.h> 
                ||      #include <sys/shm.h>
                ||      void *shmat(int shmid, const void *shmaddr, int shmflg);
                ----功能
                    --->将一个共享内存段映射到调用进程的数据段中。
                ----参数
                    --->shmid:共享内存标识符。
                    --->shmaddr:共享内存映射地址(若为NULL则由系统自动指定)，推荐使用NULL。
                    --->shmflg:共享内存段的访问权限和映射条件
                        -->0:共享内存具有可读可写权限。
                        -->SHM_RDONLY:只读。
                        -->SHM_RND:(shmaddr非空时才有效)
                            --没有指定SHM_RND则此段连接到shmaddr所指 定的地址上(shmaddr必需页对齐)。
                            --指定了SHM_RND则此段连接到shmaddrshmaddr%SHMLAB所表示的地址上
                ----返回值
                    --->成功:返回共享内存段首地址
                    --->失败:返回 -1
                ----注:
                    --->shmat函数使用的时候第二个和第三个参数一般设为NULL和0，即系统自动指定共享内存地址，并且共享内存可读可写。
            ----解除共享内存映射(detach)
                ||      #include <sys/ipc.h> 
                ||      #include <sys/shm.h>
                ||      int shmdt(const void *shmaddr);
                ----功能
                    --->将共享内存和当前进程分离(仅仅是断开联系并不删除共享内存)
                ----参数
                    --->shmaddr:共享内存映射地址
                ----返回值
                    --->成功返回 0，失败返回 -1。
            ----共享内存控制
                ||      #include <sys/ipc.h> 
                ||      #include <sys/shm.h>
                ||      int shmctl(int shmid, int cmd, struct shmid_ds *buf);
                ----功能
                    --->共享内存空间的控制。
                ----参数
                    --->shmid:共享内存标识符。
                    --->cmd:函数功能的控制
                        -->IPC_RMID:删除。
                        -->IPC_SET:设置shmid_ds参数。
                        -->IPC_STAT:保存shmid_ds参数。
                        -->SHM_LOCK:锁定共享内存段(超级用户)。
                        -->SHM_UNLOCK:解锁共享内存段。
                    --->buf:shmid_ds数据类型的地址，用来存放或更改消息队列的属性
                ----返回值
                    --->成功返回 0，失败返回 -1。
            ----注意
                --->SHM_LOCK用于锁定内存，禁止内存交换。
                --->并不代表共享内存被锁定后禁止其它进程访问。
                --->其真正的意义是:被锁定的内存不允许被交换到虚拟内存中。
                --->这样做的优势在于让共享内存一直处于内存中，从而提高程序性能。
第八章 信号
    1)信号(signal)概述
        ----信号是软件中断，它是在软件层次上对中断机制的一种模拟。
            --->信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
        ----信号是一种异步通信方式。
            --->进程不必等待信号的到达，进程也不知道信号什么时候到达。
        ----信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。
        ----每个信号的名字都以字符SIG开头。
        ----每个信号和一个数字编码相对应
            ----在头文件signum.h中，这些信号都被定义为正整数。
        ----参考路径:/usr/include/i386-linux-gnu/bits/signum.h
        ----在Linux下，要想查看这些信号和编码的对应关系，可使用命令:kill -l
            ||  kill示例
            ||      yyz@yyz-virtual-machine:~$ kill -l
            ||       1) SIGHUP	    2) SIGINT	    3) SIGQUIT	    4) SIGILL	    5) SIGTRAP
            ||       6) SIGABRT	    7) SIGBUS	    8) SIGFPE	    9) SIGKILL	    10) SIGUSR1
            ||      11) SIGSEGV	    12) SIGUSR2	    13) SIGPIPE	    14) SIGALRM	    15) SIGTERM
            ||      16) SIGSTKFLT	17) SIGCHLD	    18) SIGCONT	    19) SIGSTOP	    20) SIGTSTP
            ||      21) SIGTTIN	    22) SIGTTOU	    23) SIGURG	    24) SIGXCPU	    25) SIGXFSZ
            ||      26) SIGVTALRM	27) SIGPROF	    28) SIGWINCH	29) SIGIO	    30) SIGPWR
            ||      31) SIGSYS	    34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
            ||      38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
            ||      43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
            ||      48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
            ||      53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
            ||      58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
            ||      63) SIGRTMAX-1	64) SIGRTMAX	
            ||
        ----以下条件可以产生一个信号 
            1.当用户按某些终端键时，将产生信号。
                ----例如
                    --->终端上按“Ctrl+c”组合键通常产生中断信号SIGINT
                    --->终端上按"Ctrl+\"键通常产生中断信号SIGQUIT
                    --->终端上按"Ctrl+z"键通常产生中断信号SIGSTOP。
            2.硬件异常将产生信号。
                ----除数为0，无效的内存访问等。
                ----这些情况通常由硬件检测到，并通知内核,然后内核产生适当的信号发送给相应的进程。
            3.软件异常将产生信号。
                ----当检测到某种软件条件已发生，并将其通知有关进程时，产生信号。 
            4.调用kill函数将发送信号。
                ----注意:接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。 
            5.运行kill命令将发送信号。
                ----此程序实际上是使用kill函数来发送信号。也常用此命令终止一个失控的后台进程。
        ----一个进程收到一个信号的时候，可以用如下方法进行处理
            1.忽略此信号
                ----大多数信号都可以使用这种方式处理
                ----但SIGKILL和SIGSTOP决不能被忽略
                    --->原因是它们向超级用户提供一种使进程终止的可靠方法。
            2.执行系统默认动作
                ----对大多数信号来说，系统默认动作是用来终止该进程。
            3.自定义信号处理函数
                ----用用户定义的信号处理函数处理该信号。
    2)信号的基本操作 
        1.给指定进程发送信号
            ||  #include <sys/types.h>
            ||  #include <signal.h>
            ||  int kill(pid_t pid, int signum);
            ----功能
                --->给指定进程发送信号。
            ----参数
                --->pid
                    -->pid的取值有4种情况
                        --pid>0: 将信号传送给进程ID为pid的进程。
                        --pid=0: 将信号传送给当前进程所在进程组中的所有进程。
                        --pid=-1: 将信号传送给系统内所有的进程。
                        --pid<-1: 将信号传给指定进程组的所有进程。这个进程组号等于pid的绝对值。
                --->signum:信号的编号
            ----返回值
                --->成功返回 0，失败返回 -1
            ----例:01_kill.c
                ||
                ||
                ----注意:使用kill函数发送信号，接收信号进程和发送信号进程的所有者"必须相同"，或者发送信号进程的所有者是"超级用户"。
        2.定时器
            ||  #include <unistd.h>
            ||  unsigned int alarm(unsigned int seconds);
            ----功能
                --->在seconds秒后，向调用进程发送一个SIGALRM信号，SIGALRM信号的默认动作是终止调用alarm函数的进程。
            ----返回值
                --->若以前没有设置过定时器，或设置的定时器已超时，返回0；
                --->否则返回定时器剩余的秒数，并重新设定定时器。
            ----例:02_alarm.c
                ||
                ||
            ----注意:一个进程只有一个闹钟，多次设置的话，采用最后设置的(重修设置)
        3.给调用进程本身送一个信号
            ||  #include <signal.h>
            ||  int raise(int signum);
            ----功能
                --->给调用进程本身送一个信号。
            ----参数
                --->signum:信号的编号。
            ----返回值
                --->成功返回 0，失败返回 -1。
            ----例:03_raise.c
                ||
                ||
        4.判断信号是否已到
            ||  #include <unistd.h>
            ||  int pause(void);    //无参<一个pause只能等待一个信号>
            ----功能
                --->将调用进程挂起直至捕捉到信号为止。这个函数通常用于判断信号是否已到。
            ----返回值
                --->直到捕获到信号，pause函数才返回-1，且errno被设置成EINTR。
            ----例:04_pause.c
                ||
                ||
        5.进程流产
            ||  #include <stdlib.h>
            ||  void abort(void);    
            ----功能
                --->向进程发送一个SIGABRT信号，默认情况下进程会退出。
            ----注意
                --->即使SIGABRT信号被加入阻塞集，一旦进程调用了abort函数，进程也还是会被终止
                --->且在终止前会刷新缓冲区，关文件描述符。
        6.处理信号的函数主要有如下三种
            1)signal函数
                ----注册信号处理函数
                    ||  #include <signal.h>
                    ||  typedef void (*sighandler_t)(int)；
                    ||  sighandler_t signal(int signum,sighandler_t handler);
                    ----功能
                        --->注册信号处理函数(除了SIGKILL信号、SIGSTOP信号)，即确定收到信号后处理函数的入口地址。
                    ----参数
                        --->signum:信号编号 
                        --->handler:
                            -->hander的取值
                                --忽略该信号:SIG_IGN
                                --执行系统默认动作:SIG_DFL
                                --自定义信号处理函数:处理函数名 
                    ----返回值
                        --->成功:返回函数地址，该地址为此信号上一次注册的信号处理函数的地址。
                        --->失败:返回SIG_ERR
                    ----例:05_signal_1.c  05_signal_2.c
                        ||
                        ||
                ----可重入函数
                    --->可重入函数是指函数可以由多个任务并发使用，而不必担心数据错误。
                    --->编写可重入函数:
                        1)不使用(返回)静态的数据、全局变量(除非用信号量互斥)。
                        2)不调用动态内存分配、释放的函数。
                        3)不调用任何不可重入的函数(如标准I/O函数)
                    --->注
                        -->即使信号处理函数使用的都是可重入函数(常见的可重入函数)
                        -->也要注意进入处理函数时，首先要保存errno的值，结束时，再恢复原值。
                        -->因为，信号处理过程中，errno值随时可能被改变。
            2)信号集函数组 
                ----信号集
                    --->信号集概述
                        -->一个用户进程常常需要对多个信号做出处理。
                            --为了方便对多个信号进行处理，在Linux系统中引入了信号集。
                        -->信号集是用来表示多个信号的数据类型。
                    --->信号集相关的操作主要有如下几个函数
                        -->sigemptyset 
                            ||  #include <signal.h>
                            ||  int sigemptyset(sigset_t *set)；
                            ----功能
                                --->初始化由set指向的信号集，清除其中所有的信号即初始化一个空信号集。
                            ----参数
                                --->set
                                    -->信号集标识的地址
                                    -->以后操作此信号集，对set进行操作就可以了。
                            ----返回值
                                --->成功返回 0，失败返回 -1。
                        -->sigfillset 
                            ||  #include <signal.h>
                            ||  int sigfillset(sigset_t *set)
                            ----功能
                                --->初始化信号集合set, 将信号集合设置为所有信号的集合。
                            ----参数
                                --->信号集标识的地址，以后操作此信号集，对set进行操作就可以了。
                            ----返回值
                                --->成功返回 0，失败返回 -1。
                        -->sigismember 
                            ||  #include <signal.h>
                            ||  int sigismember(const sigset_t *set,intsignum);
                            ----功能
                                --->查询signum标识的信号是否在信号集合set之中。
                            ----参数
                                --->set
                                    -->信号集标识符号的地址。
                                --->signum
                                    -->信号的编号。
                            ----返回值
                                --->在信号集中返回 1
                                --->不在信号集中返回 0
                                --->错误，返回 -1
                        -->sigaddset 
                            ||  #include <signal.h>
                            ||  int sigaddset(sigset_t *set, int signum);
                            ----功能
                                --->将信号signo加入到信号集合set之中。
                            ----参数
                                --->set:信号集标识的地址。
                                --->signum:信号的编号。
                            ----返回值
                                --->成功返回 0，失败返回 -1。
                        -->sigdelset
                            ||  #include <signal.h>
                            ||  int sigdelset(sigset_t *set, int signum);
                            ----功能:将signum所标识的信号从信号集合set中删除。
                            ----参数
                                --->set:信号集标识的地址。
                                --->signum:信号的编号。
                            ----返回值
                                --->成功:返回 0
                                --->失败:返回 -1
                        -->例:06_signal_set.c
                        -->信号阻塞集(屏蔽集、掩码)
                            --信号阻塞集概述
                                ->每个进程都有一个阻塞集，它用来描述哪些信号递送到该进程的时候被阻塞(在信号发生时记住它，直到进程准备好时再将信号通知进程)。
                                ->所谓阻塞并不是禁止传送信号, 而是暂时停止信号的传送。
                                ->若将被阻塞的信号从信号阻塞集中删除，且对应的信号在被阻塞时发生了，进程将会收到相应的信号。
                                ||  #include <signal.h>
                                ||  int sigprocmask(int how,const sigset_t *set, sigset_t *oldset)；
                                ----功能
                                    --->检查或修改信号阻塞集
                                    --->根据how指定的方法对进程的阻塞集合进行修改
                                    --->新的信号阻塞集由set指定
                                    --->而原先的信号阻塞集合由oldset保存。
                                ----参数
                                    --->how:信号阻塞集合的修改方法。
                                        -->SIG_BLOCK:向信号阻塞集合中添加set信号集
                                        -->SIG_UNBLOCK:从信号阻塞集合中删除set集合
                                        -->SIG_SETMASK:将信号阻塞集合设为set集合
                                        -->注
                                            --若set为NULL，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到oldset中。
                                    --->set:要操作的信号集地址。
                                    --->oldset:保存原先信号集地址。(NULL 不保存)
                                ----返回值
                                    --->成功:返回 0 失败:返回 -1
                                ----例:06_sigprocmask.c
                                    ||
                                    ||
            3)sigaction函数
                ----前言
                    --->signal函数只能提供简单的信号安装操作。
                        -->使用signal函数处理信号比较简单，只要把要处理的信号和处理函数列出即可。
                    --->signal函数主要用于前面32种不可靠、非实时信号的处理，并且不支持信号传递信息。
                        -->在Linux系统中不可靠的信号是指信号可能会丢失
                    --->Linux提供了功能更强大的"sigaction"函数
                        -->此函数可以用来检查和更改信号处理操作
                        -->可以支持可靠、实时信号的处理，并且支持信号传递信息。
                ----可靠(实时)、不可靠信号(非可靠)
                    --->从UNIX系统继承过来的信号(SIGHUP～SIGSYS)都是不可靠信号，不支持排队(多次发送相同的信号,进程可能只能收到一次，可能会丢失)。
                    --->SIGRTMIN至SIGRTMAX的信号支持排队(发多少次, 就可以收到多少次, 不会丢失)，故称为可靠信号。
                ----实时、非实时信号
                    --->可靠信号就是实时信号，非可靠信号就是非实时信号。
                ----实时信号(可靠信号)的优势
                    --->多个实时信号可以同时发生并传送给相应的进程。 
                    --->实时信号可以传参(整数或任意类型的地址)。
                    --->实时信号可以保证信号传递的顺序(传递顺序和信号产生的顺序相同)。
                ----给指定进程发送信号
                    ||  #include <signal.h>
                    ||  int sigqueue(pid_t pid, int sig,const union sigval value);
                    ----功能
                        --->给指定进程发送信号。
                    ----参数
                        --->pid:进程号。
                        --->sig:信号的编号。
                        --->value:通过信号传递的参数。
                    ----信号传递的参数
                        ||  union sigval
                        ||  {
                        ||      int sival_int;
                        ||      void *sival_ptr;
                        ||  };
                    ----返回值
                        --->成功返回 0，失败返回 -1
                ----检查或修改指定信号的设置(或同时执行这两种操作。)
                    ||  #include <signal.h>
                    ||  int  sigaction(int signum,const struct sigaction *act,struct sigaction *oldact)；
                    ----功能
                        --->检查或修改指定信号的设置(或同时执行这两种操作。)
                    ----参数
                        --->signum:信号编号。
                        --->act:新的信号设置指针。
                        --->oldact:旧的信号设置指针。
                ----sigaction函数
                    --->功能
                        -->如果act指针非空，则要改变指定信号的设置
                        -->如果oldact指针非空，则系统将此前指定信号的设置存入oldact。
                    --->返回值
                        -->成功:0 失败:-1
                    --->信号设置结构体
                        ||  struct sigaction
                        ||  {
                        ||    /*旧的信号处理函数指针*/
                        ||    void (*sa_handler)(int signum) ;
                        ||    /*新的信号处理函数指针*/
                        ||    void (*sa_sigaction)(int signum, siginfo_t *info, void *context);
                        ||    sigset_t sa_mask;/*信号阻塞集*/
                        ||    int sa_flags;/*信号处理的方式*/
                        ||  };
                        ||    
                        ----sa_handler、sa_sigaction
                            --->信号处理函数指针
                                -->忽略该信号:SIG_IGN
                                -->执行系统默认动作:SIG_DFL
                                -->自定义信号处理函数:处理函数名
                            --->注:应根据情况给sa_sigaction、sa_handler两者之一赋值。
                        ----sa_mask
                            --->信号处理函数执行期间要阻塞的信号集(但不阻塞SIGKILL、SIGSTOP)。
                        ----sa_flags
                            --->用来决定信号的行为。
                            --->不指定SA_SIGINFO
                                -->信号的处理函数应由sa_handler设置。
                                -->可完成与signal函数一样的功能。
                            --->指定SA_SIGINFO
                                -->信号的处理函数应由sa_sigaction设置。
                                -->它的功能更强大，除了获取基本的信号值外，还可以获取此信号发送者及接收者的部分信息。
                        ----例:07_sigaction_1.c  07_sigaction_2.c
                            ||
                            ||
                    --->信号处理函数
                        ||  void (*sa_sigaction)(int signum,siginfo_t *info, void *context);
                        ----参数
                            --->signum:信号的编号。
                            --->info:记录信号发送进程信息的结构体。
                            --->context:可以赋给指向ucontext_t类型的一个对象的指针，以引用在传递信号时被中断的接收进程或线程的上下文。
                        ----进程信息结构体路径
                            --->/usr/include/i386-linux-gnu/bits/siginfo.h
                        ----发送进程信息的结构体:siginfo_t
                        ----接收进程或线程的上下文结构体:ucontext_t
                        ----例:07_sigaction_3_rcv.c 07_sigaction_3_snd.c
第九章 线程
    1)线程概述
        1.线程的由来
            ----每个进程都拥有自己的数据段、代码段和堆栈段
                --->这就造成进程在进行创建、切换、撤销操作时，需要较大的系统开销。
            ----为了减少系统开销，从进程中演化出了线程。
            ----线程存在于进程中，共享进程的资源。
            ----线程是进程中的独立控制流，由环境(包括寄存器组和程序计数器)和一系列的执行指令组成。
            ----线程的概念
                --->每个进程有一个地址空间、和一个控制线程。
                --->"E:\学习笔记\其他资料\Linux\Image\线程的概念.jpg"
        2.线程和进程的比较
            ----传统意义上的进程被称为重量级进程(heavyweightprocess, HWP)
                --->从现代角度看，就是只拥有一个线程的进程。
            ----线程与进程有很多类似的性质，习惯上也称线程为轻量级进程(lightweight process, LWP)或称为迷你进程。
        3.调度
            ----线程是CPU调度和分派的基本单位。
            ----进程是系统中程序执行和资源分配的基本单位。
        4.拥有资源:
            ----进程是拥有系统资源的一个独立的单位，它可以拥有自己的资源。
            ----线程自己一般不拥有资源(除了必不可少的程序计数器，一组寄存器和栈)
                --->但它可以去访问其所属进程的资源，如进程代码段，数据段以及系统资源(已打开的文件，I/O设备等)。
        5.并发性
            ----不仅进程间可以并发执行，在一个进程中的多个线程之间也可以并发执行。
        6.系统开销
            ----同一个进程中的多个线程可共享同一地址空间，因此它们之间的同步和通信的实现也变得比较容易。
            ----在进程切换时候
                --->涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置；
            ----而线程切换
                --->只需要保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作，从而能更有效地使用系统资源和提高系统的吞吐量。
        7.使用多线程的目的主要有以下几点
            ----多任务程序的设计
                --->一个程序可能要处理不同应用，要处理多种任务
                --->如果开发不同的进程来处理，系统开销很大
                --->数据共享，程序结构都不方便，这时可使用多线程编程方法。
            ----并发程序设计
                --->一个任务可能分成不同的步骤去完成
                --->这些不同的步骤之间可能是松散耦合
                --->可能通过线程的互斥，同步并发完成。
                --->这样可以为不同的任务步骤建立线程。
            ----网络程序设计
                --->为提高网络的利用效率，我们可能使用多线程，对每个连接用一个线程去处理。
            ----数据共享
                --->同一个进程中的不同线程共享进程的数据空间，方便不同线程间的数据共享。
            ----在多CPU系统中，实现真正的并行。
    2)线程的基本操作
        1.前言
            ----就像每个进程都有一个进程号一样，每个线程也有一个线程号。
            ----进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。
            ----进程号用pid_t数据类型表示，是一个非负整数。线程号则用pthread_t数据类型来表示。
            ----有的系统在实现pthread_t的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把它做为整数处理。
        2.创建一个线程
            ||  #include <pthread.h>
            ||  int pthread_create(pthread_t *thread,
            ||                  const pthread_attr_t *attr,
            ||                  void *(*start_routine)(void*),
            ||                  void * arg);
            ----功能
                --->创建一个线程。
            ----参数
                --->thread:线程标识符地址。
                --->attr:线程属性结构地址。
                --->start_routine:线程函数的入口地址。
                --->arg:传给新线程执行函数的参数。(少:直接给   多:数组、结构体)
            ----返回值
                --->成功返回 0，失败返回非 0；
            ----与fork不同的是pthread_create创建的线程不与父线程在同一点开始运行，而是从指定的函数开始运行，该函数运行完后，该线程也就退出了。
            ----线程是依赖进程存在的，如果创建线程的进程结束了，线程也就结束了。 
            ----线程函数的程序在pthread库中，故链接时要加上参数-lpthread。
                --->gcc pthread_test.c -o pthread_test -lpthread
            ----例:01_pthread_create.c
                ||
                ||
        3.等待子线程结束，并回收子线程资源
            ||  #include <pthread.h>
            ||  int pthread_join(pthread_t thread, void **value_ptr);
            ----功能
                --->等待子线程结束，并回收子线程资源。
            ----参数
                --->thread:被等待的线程号。
                --->value_ptr:指针的地址
                    -->调用此函数后，指针指向一个存储线程完整退出状态的静态区域，可用来存储被等待线程的返回值。(pthread_exit的返回值)
            ----返回值
                --->成功返回0，失败返回非0。
            ----例:02_pthread_join.c
                ||
                ||
            ----创建一个线程后应回收其资源
                --->但使用"pthread_join"函数会使调用者阻塞
                --->故Linux提供了线程分离函数:pthread_detach。
        4.回收线程资源
            ||  #include <pthread.h>
            ||  int pthread_detach(pthread_t thread);
            ----功能
                --->使调用线程与当前进程分离，使其成为一个独立的线程
                --->该线程终止时，系统将自动回收它的资源。
            ----参数
                --->thread:线程ID
                    -->分离出去的线程，在进程结束后，分离出的线程也结束
            ----返回值
                --->成功返回0，失败返回非0。
            ----例:03_pthread_detach.c
                ||
                ||
        5.结束线程
            ----在进程中我们可以调用exit函数或_exit函数来结束进程
            ----在一个线程中我们可以通过以下三种在不终止整个进程的情况下停止它的控制流。
                1)线程从执行函数中返回。(自然死亡)
                2)线程调用pthread_exit退出线程。(自杀)
                3)线程可以被同一进程中的其它线程取消。(谋杀)
                ||  #include <pthread.h>
                ||  void pthread_exit(void *value_ptr);
                ----功能
                    --->使调用线程退出。
                ----参数
                    --->value_ptr
                        -->指向线程退出状态的静态区域，在别的线程中可用pthread_join访问。
                        -->一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源并不会释放。
                ----例:04_pthread_exit.c
                    ||
                    ||
        6.取消线程
            ----取消线程是指取消一个正在执行线程的操作。
                ||  #include <pthread.h>
                ||  int pthread_cancel(pthread_t thread);
                ----功能
                    --->取消线程。
                ----参数
                    --->thread:目标线程ID。
                ----返回值
                    --->成功返回 0，失败返回出错编号。
                ----pthread_cancel函数的实质是发信号给目标线程thread，使目标线程退出。
                    --->此函数只是发送终止信号给目标线程，不会等待取消目标线程执行完才返回。
                    --->然而发送成功并不意味着目标线程一定就会终止，线程被取消时，"线程的取消属性"会决定线程能否被取消以及何时被取消。
                        -->线程的取消状态(默认是可被取消的)
                        -->线程取消点
                        -->线程的取消类型(立即取消与寻找取消点)
        7.线程的取消状态
            ----在Linux系统下，线程默认可以被取消。
            ----编程时可以通过pthread_setcancelstate函数设置线程是否可以被取消。
                ||  pthread_setcancelstate(int state,int *old_state); 
                ----参数
                    --->state
                        -->PTHREAD_CANCEL_DISABLE:不可以被取消
                        -->PTHREAD_CANCEL_ENABLE:可以被取消。
                    --->old_state
                        --->保存调用线程原来的可取消状态的内存地址。
            ----例:05_pthread_setcancelstate.c
                ||
                ||
        8.线程的取消点
            ----线程被取消后，该线程并不是马上终止，默认情况下线程执行到消点时才能被终止。
            ----编程时可以通过pthread_testcancel函数设置线程的取消点。
                ||  void pthread_testcancel(void);(可以被取消时不允许空)
                ----当别的线程取消调用此函数的线程时候，被取消的线程执行到此函数时结束。
                ----POSIX.1保证线程在调用表1、表2中的任何函数时，取消点都会出现。
            ----例:05_pthread_testcancel.c
                ||
                ||
        9.线程的取消类型
            ----线程被取消后，该线程并不是马上终止，默认情况下线程执行到取消点时才能被终止。
            ----编程时可以通过pthread_setcanceltype函数设置线程是否可以立即被取消。
                ||  pthread_setcanceltype(int type,int *oldtype);
                ----参数
                    --->type
                        -->PTHREAD_CANCEL_ASYNCHRONOUS:立即取消
                        -->PTHREAD_CANCEL_DEFERRED:不立即被取消
                    --->oldtype
                        -->保存调用线程原来的可取消类型的内存地址。
            ----例:05_pthread_setcanceltype.c
                ||
                ||
        10.线程清理处理程序
            ----和进程的退出清理一样，线程也可以注册它退出时要调用的函数，这样的函数称为线程清理处理程序(thread cleanup handler)。
            ----注意
                --->线程可以建立多个清理处理程序。
                --->处理程序在栈中，故它们的执行顺序与它们注册时的顺序相反。
                ||  #include <pthread.h>
                ||  void pthread_cleanup_push(void (*routine)(void*), void *arg);
                ----功能
                    --->将清除函数压栈。即注册清理函数。
                ----参数
                    --->routine:线程清理函数的指针。
                    --->arg:传给线程清理函数的参数。
                ||  #include <pthread.h>
                ||  void pthread_cleanup_pop(int execute);
                ----功能
                    --->将清除函数弹栈，即删除清理函数。
                ----参数
                    --->execute:线程清理函数执行标志位。
                        -->非0，弹出清理函数，执行清理函数。
                        -->0，弹出清理函数，不执行清理函数
            ----当线程执行以下动作时会调用清理函数
                --->调用pthread_exit退出线程。
                --->响应其它线程的取消请求。
                --->用非零execute调用pthread_cleanup_pop。
                    -->无论哪种情况pthread_cleanup_pop都将删除上一次pthread_cleanup_push调用注册的清理处理函数。
            ----注意
                --->pthread_cleanup_pop、pthread_cleanup_push必须配对使用。
            ----例:06_pthread_cleanup_exit.c
                ||
                ||
    3)线程同步互斥
        1.概念
            ----同步
                --->两个或两个以上的线程在运行过程中协同步调，按预定的先后次序运行。 
            ----互斥
                --->一个公共资源同一时刻只能被一个线程使用，多个线程不能同时使用公共资源。
                --->POSIX标准中线程同步和互斥的方法,主要有信号量和互斥锁两种方式。
        2.互斥锁(mutex)
            ----mutex是一种用简单的加锁的方法来控制对共享资源的访问
            ----mutex只有两种状态
                --->上锁(lock)
                --->解锁(unlock)。
            ----在访问该资源前，首先应申请mutex
                --->如果mutex处于unlock状态，则会申请到mutex并立即lock；
                --->如果mutex处于lock状态，则默认阻塞申请者。
            ----unlock操作应该由lock者进行。
            ----mutex用pthread_mutex_t数据类型表示
                --->在使用互斥锁前,必须先对它进行初始化。
                    -->静态分配的互斥锁
                        ||  pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
                    -->动态分配互斥锁
                        ||  pthread_mutex_t mutex;
                        ||  pthread_mutex_init(&mutex, NULL);
            ----在所有使用过此互斥锁的线程都不再需要使用时候，应调用pthread_mutex_destroy销毁互斥锁。
            ----初始化一个互斥锁
                ||  #include <pthread.h>
                ||  int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr)；
                ----功能
                    --->初始化一个互斥锁。
                ----参数
                    --->mutex
                        -->互斥锁地址
                    --->attr:
                        -->互斥锁的属性，NULL为默认的属性。
                ----返回值
                    --->成功返回0，失败返回非0。
            ----对互斥锁上锁(方法一)
                ||  #include <pthread.h>
                ||  int pthread_mutex_lock(pthread_mutex_t *mutex);
                ----功能
                    --->对互斥锁上锁，若已经上锁，则调用者一直阻塞到互斥锁解锁。
                ----参数
                    --->mutex
                        -->互斥锁地址
                ----返回值
                    --->成功返回0，失败返回非0。
            ----对互斥锁上锁(方法二)
                ||  #include <pthread.h>
                ||  int pthread_mutex_trylock(pthread_mutex_t *mutex);
                ----功能
                    --->对互斥锁上锁，若已经上锁，则上锁失败，函数立即返回。
                ----参数
                    --->mutex
                        -->互斥锁地址
                ----返回值
                    --->成功返回0，失败返回非0。
            ----对指定的互斥锁解锁
                ||  #include <pthread.h>
                ||  int pthread_mutex_unlock(pthread_mutex_t * mutex);
                ----功能
                    --->对指定的互斥锁解锁。
                ----参数
                    --->mutex:互斥锁地址。
                ----返回值
                    --->成功返回0,失败返回非0。
            ----销毁指定的一个互斥锁
                ||  #include <pthread.h>
                ||  int pthread_mutex_destroy(pthread_mutex_t *mutex);
                ----功能
                    --->销毁指定的一个互斥锁。
                ----参数
                    --->mutex
                        -->互斥锁地址。
                ----返回值:成功返回0，失败返回非0。
            ----例:07_pthread_mutex.c
                ||
                ||
        3.信号量
            ----信号量广泛用于进程或线程间的同步和互斥
                --->信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。 
            ----进程或线程根据信号量操作结果的值判断是否对公共资源具有访问的权限
                --->当信号量值大于０时，则可以访问，否则将阻塞。
            ----信号量用于互斥
                --->"E:\学习笔记\其他资料\Linux\Image\信号量用于互斥.jpg"
            ----信号量用于同步
                --->"E:\学习笔记\其他资料\Linux\Image\信号量用于同步.jpg"
            ----创建一个信号量并初始化它的值。
                ||  #include <semaphore.h>
                ||  int sem_init(sem_t *sem, int pshared,unsigned int value);
                ----功能
                    --->创建一个信号量并初始化它的值。
                ----参数
                    --->sem
                        -->信号量地址。
                    --->pshared
                        -->决定信号量能否在几个进程间共享，目前Linux没有实现进程间共享信号量，故此值只能为0。
                    --->value
                        -->信号量的初始值。
                ----返回值
                    --->成功返回0，失败返回-1。
            ----将信号量的值减1，若信号量的值小于0，此函数会引起调用者阻塞。
                ||  #include <semaphore.h>
                ||  int sem_wait(sem_t *sem);
                ----功能
                    --->将信号量的值减1，若信号量的值小于0，此函数会引起调用者阻塞。
                ----参数
                    --->sem:信号量地址。
                ----返回值
                    --->成功返回0，失败返回-1
            ----将信号量的值减1，若信号量的值小于0，则对信号量的操作失败，函数立即返回。
                ||  #include <semaphore.h>
                ||  int sem_trywait(sem_t *sem);
                ----功能
                    --->将信号量的值减1，若信号量的值小于0，则对信号量的操作失败，函数立即返回。
                ----参数
                    --->sem
                        -->信号量地址
                ----返回值
                    --->成功返回0,失败返回-1。
            ----将信号量的值加1并发出信号唤醒等待线程
                ||  #include <semaphore.h>
                ||  int sem_post(sem_t *sem);
                ----功能
                    --->将信号量的值加1并发出信号唤醒等待线程。
                ----参数
                    --->sem
                        -->信号量地址
                ----返回值
                    --->成功返回0，失败返回-1
            ----获取sem标识的信号量的值，保存在sval中
                ||  #include <semaphore.h>
                ||  int sem_getvalue(sem_t *sem, int *sval);
                ----功能
                    --->获取sem标识的信号量的值，保存在sval中。
                ----参数
                    --->sem
                        -->信号量地址
                    --->sval
                        -->保存信号量值的地址。
                ----返回值
                    --->成功返回0，失败返回-1。
            ----删除sem标识的信号量
                ||  #include <semaphore.h>
                ||  int sem_destroy(sem_t *sem);
                ----功能
                    --->删除sem标识的信号量。
                ----参数
                    --->sem:信号量地址。
                ----返回值
                    --->成功返回0，失败返回-1。
                ----例
                    --->08_semphore_1.c 08_semphore_2.c
        4.练习
            ----生产者消费者
                --->有一个仓库，生产者负责生产产品，并放入仓库，消费者会从仓库中拿走产品(消费)。
                --->要求
                    -->仓库中每次只能入一人(生产者或消费者)。
                    -->仓库中可存放产品的数量最多10个,当仓库放满时，生产者不能再放入产品。
                    -->当仓库空时，消费者不能从中取出产品。
                    -->生产、消费速度不同。
第十章 计算机网络概述
    1.计算机网络发展简史
        1)最早的广域网——电路交换网
            ----定义
                --->在通信双方或多方之间，通过电路交换建立电路连接的网络
                    -->"E:\学习笔记\其他资料\Linux\Image\电路交换网.jpg"
            ----特点
                ---> 建立链接->使用链接->释放链接(实电路)
                ---> 物理通路被通信双方独占
                ---> 计算机数据是突发式出现在数据链路上的
                    --> 而电路交换网的建立链接、使用链接、释放链接的三个过程使得传输效率太低，故电路交换不适合传输计算机数据
        2)ARPA
            ----1957年10月4日,苏联发射了世界上第一颗人造地球卫星——Sputnik
            ----针对Sputnik所带来的威胁,美国国会于1958年1月7日拨款成立ARPA(the Advanced ResearchProjects Agency 美国高级研究计划署)
            ----ARPA对计算机网络的要求
                --->不是为了打电话
                --->能够连接不同种类的计算机
                --->所有网络节点同等重要
                --->必须有冗余的路由
                --->结构简单，能可靠的传输数据
        3)分组交换
            ----定义
                --->通过标有地址的分组进行路由选择传送数据，使信道仅在传送分组期间被占用的一种交换方式
            ----分组的组成
                --->每个分组都由首部和数据段组成
                --->"E:\学习笔记\其他资料\Linux\Image\分组的组成.jpg"
            ----交换方式
                --->存储转发
                    -->节点收到分组，先暂时存储下来，再检查其首部，按照首部中的目的地址，找到合适的接口转发出去
            ----分组交换的优点
                --->高效
                    -->在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用的
                --->灵活
                    -->为每一个分组独立的选择转发路由
                --->迅速
                    -->以分组作为传输单位，可以不先建立连接就能向其他主机发送分组
                --->可靠
                    -->完整的网络协议
                    -->分布式多路由的分组交换网，使网络有很好的生存性
    2.进入因特网时代
        ----从单个ARPANET向互联网发展的过程
            ---> 1983 年TCP/IP协议成为APRANET的标准协议
        ----三级结构的因特网(NSFNET国家科学基金网)
            --->围绕六台大型计算机中心建设起来的计算机网络
            --->主干网、地区网、校园网
            --->"E:\学习笔记\其他资料\Linux\Image\三级结构的因特网.jpg"
        ----多级结构因特网
            --->NSFNET逐步被商用因特网主干网替代
            --->"E:\学习笔记\其他资料\Linux\Image\多级结构因特网.jpg"
    3.TCP/IP协议简介
        1)发展脉络
            ----ARPANet发展过程中，美国政府要求计算机设备必须从不同厂家购进，防止垄断，促进竞争
            ----为了使各种不同的计算机之间可以互联,ARPANet指定了一套计算机通信协议，即TCP/IP协议(族)
            ----时至今日，TCP/IP协议广泛应用于世界的各个角落，各种领域
        2)分层结构
            ----为了减少协议设计的复杂性，大多数网络模型均采用按层的方式来组织
                --->每一层利用下一层提供的服务来为上一层提供服务
                --->本层服务的实现细节对上层屏蔽
            ----OSI/RM协议(开放系统互联参考模型
                --->物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
            ----TCP/IP协议数据链路层、网络层、运输层、应用层
            ----OSI/RM协议是理论上的标准，而TCP/IP协议是事实上的标准
        3)TCP/IP协议的层次结构
            ----TCP/IP协议是一组包括IP协议、TCP协议、UDP协议、ICMP协议和其他一些协议的协议族
            ----TCP/IP协议采用了4层的层级结构
            ----"E:\学习笔记\其他资料\Linux\Image\TCPIP分层.jpg"
        4)TCP/IP协议族
            ----应用层:应用程序间沟通的层
                --->FTP、Telnet、HTTP、SMTP等
            ----传输层:提供进程间的数据传送服务
                --->这一层负责传送数据，提供应用程序端到端的逻辑通信
                --->传输控制协议(TCP)，用户数据报协议(UDP)
            ----网络层:提供基本的数据封包传送功能
                --->尽最大可能的让每个数据包都能够到达目的主机
                --->网际协议(IP)
            ----数据链路层:负责数据帧的发送和接收
            ----TCP/IP协议族每一层都呼叫它的下一层所提供的服务来完成自己的需求
            ----"E:\学习笔记\其他资料\Linux\Image\TCPIP协议族.jpg"
        5)IP协议(网际协议)
            ----特指为实现在一个相互连接的网络系统上从源地址到目的地传输数据包(互联网数据包)所提供必要功能的协议
            ----特点
                --->不可靠
                    -->它不能保证IP数据报能成功地到达目的地，仅提供尽力而为的传输服务
                --->无连接
                    -->IP并不维护任何关于后续数据报的状态信息。
                    -->每个数据报的处理是相互独立的。
                    -->IP数据报可以不按发送顺序接收
            ----IP数据包中含有发送它的主机的IP地址(源地址)和接收它的主机的IP地址(目的地址)
        6)TCP协议(传输控制协议)
            ----TCP是一种面向连接的，可靠的传输层通信协议
            ----功能:提供进程间通信能力
            ----特点
                --->面向连接:建立链接->使用链接->释放链接(虚电路)
                --->可靠性
                    -->对包进行排序并检错，而损坏的包可以被重传
                    -->TCP数据包中包含序号和确认序号
                    -->窗口式流量控制、慢启动和拥塞避免
            ----服务对象
                --->需要高度可靠性且面向连接的服务
                --->如Telnet、FTP、Rlogin和SMTP等
        7)UDP协议(用户数据包协议)
            ----UDP是一种面向无连接的传输层通信协议
            ----功能:提供进程间通信能力
            ----特点
                --->面向无连接:发送数据之前不需要建立链接
                --->不可靠
                    -->不对数据包的顺序进行检查
                    -->没有错误检测和重传机制
            ----服务对象
                --->主要用于那些面向查询—应答的服务
                --->例如
                    -->NFS(网络文件系统)
                    -->NTP(网络时间协议)
                    -->DNS(域名解析协议)
    4.TCP/IP协议地址
        1)物理地址
            ----定义
                --->物理地址又称MAC地址用于标志网络设备
            ----组成
                --->以太网内的物理地址是一个48bit的值
                    -->如:C8-7C-DC-B7-0F-17
                --->前24位是由生产网卡的厂商向IEEE申请的厂商地址，后24位由厂商自行分配
            ----特点
                --->以太网内的物理地址是一个48bit的值
                --->网卡生产过程中即固定
                --->与物理硬件有关
            --->位置:处于数据链路层
        2)IP地址
            ----定义
                --->IP地址是一种Internet上的主机编址方式，也称为网际协议地址
            ----组成
                --->IP是由32bit地址,由{子网ID，主机ID}两部分组成
                --->子网ID
                    -->IP地址中由子网掩码中1覆盖的连续位
                --->主机ID
                    -->表示由子网掩码中0覆盖的连续位
            ----特点
                --->子网ID不同的网络不能直接通信，如果要通信则需要路由器转发
                --->主机ID全为0的IP地址表示网段地址
                --->主机ID全为1的IP地址表示该网段的广播地址24
            ----IP地址分类如下
                --->A类地址:默认8bit子网ID,第一位为0
                --->B类地址:默认16bit子网ID,前两位为10
                --->C类地址:默认24bit子网ID,前三位为110
                --->D类地址:前四位为1110,多播地址
                --->E类地址:前五位为11110,保留为今后使用
                --->A,B,C三类地址是最常用的
        3)本地回环地址
            ----定义
                ---> 127.0.0.1通常称为本地回环地址
            ----功能
                ---> 主要是测试本机的网络配置，能PING通127.0.0.1说明本机的网卡和IP协议安装都没有问题
            ----注意
                ---> 127.0.0.1~127.255.255.254中的任何地址都将回环到本地主机中
                ---> 不属于任何一个有类别地址类,它代表设备的本地虚拟接口
        4)子网掩码
            ----子网掩码是一个32位由1和0组成的数值，并且1和0分别连续
            ----特点
                --->子网掩码不能单独存在，它必须结合IP地址一起使用
                --->子网掩码为1的位覆盖的IP位为子网ID,其余为主机ID
            ----子网掩码的表现形式
                ---> 192.168.220.0/255.255.255.0
                ---> 192.168.220.0/24 
            ----作用:可以将子网划分为更小的子网
            ----"E:\学习笔记\其他资料\Linux\Image\子网掩码.jpg"
        5)端口
            ----TCP/IP协议地址TCP/IP协议采用端口的概念用于标识通信的进程
            ----特点
                --->对于同一个端口，在不同系统中对应着不同的进程
                --->对于同一个系统，一个端口只能被一个进程拥有
            ----作用
                --->端口用于区分一个系统里的多个进程
                --->一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，进程送交传输层的数据也通过该端口被送出
            ----位置
                --->运输层
            ----端口号
                --->端口用端口号来表示，它是一个短整型的数字，每个端口都拥有一个端口号
            ----特点
                --->TCP协议,UDP协议维护各自独立的端口号
                --->网络应用进程,至少要占用一个端口号,也可以占有多个端口号
            ----常见的端口分类
                --->知名端口
                    -->范围从1到1023，一般固定分配给一些服务。
                    -->比如21端口分配给FTP服务, 80 端口分配给HTTP服务等等。
                    -->由互联网数字分配机构(IANA)据用户需要进行统一分配,并将结果公布与众
                    -->使用知名端口的服务器必须以超级用户特权启动
                --->动态端口
                    -->范围从1024到65535，一般不固定分配给某个服务。
                    -->只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配供该程序使用
            ----"E:\学习笔记\其他资料\Linux\Image\数据报文在各个层之间传输的情况.jpg"
    5.几个常见的网络概念
        1)集线器(Hub)
            ----定义
                --->作为网络中枢连接各类节点，以形成星状结构的一种网络设备
            ----功能
                --->将所有节点集中在以它为中心的节点上
                --->对接收到的信号进行再生整形放大
                --->工作于OSI/RM模型的最底层----物理层
            ----特点
                --->纯硬件网络底层设备
                --->连接在Hub上的任意一台主机发送数据时，将被Hub广播至所有机器，不会带有任何过滤
                --->该Hub上的所有主机共享带宽，且非双工传输
                --->基于上面的原因，采用Hub的局域网，很容易造成网络塞车
            ----"E:\学习笔记\其他资料\Linux\Image\集线器.jpg"
        2)交换机(Switch)
            ----定义
                --->一种基于MAC地址识别，能完成封装转发数据帧功能的网络设备
            ----功能
                --->为接入交换机的任意两个网络节点提供独享的电信号通路
                --->可以依据MAC地址进行
                --->工作于OSI/RM模型的第二层——数据链路层
                --->发展
                    --> 人工交换->电路程控交换机->以太网交换机->光交换
        3)路由器
            ----路由器:为信息流或数据分组选择路由的设备
            ----功能
                --->工作在网络层，拥有复杂的算法控制数据包转发规则,解决异性网络之间的转发分组
                --->依据IP地址寻址，并维护庞大的路由表，记录在多个子网之间传递数据时的转发路径规则
                --->可以分割子网、广播域
                --->可以提供防火墙的功能
            ----路由表:保存着各种传输路径的相关数据
            ----路由表分类
                --->静态路由表
                    -->由系统管理员根据网络的配置情况预先设定的路由表称之为静态路由表
                    -->它不会随未来网络结构的改变而改变
                --->动态路由表
                    -->动态路由表是路由器根据网络系统的运行情况而自动调整的路径表
第十一章 Socket编程
    1.概述
        ----ARPANet是我们熟知的Internet的前身
        ----在ARPANet发展的同时,UNIX也在迅速发展,加州大学Berkeley分校开发出具有自己风格的UNIX,我们通常称之为"BSD"
        ----20 世纪 80 年代初，在系统内实现了"TCP/IP协议"的4.1BSD和4.2BSD被相继开发出来
        ----加州大学Berkeley分校在BSD内实现了针对于TCP/IP协议应用程序编程接口，即"Socket"
            --->网络间通信要解决的是不同主机"进程间的通信"
                -->需要解决的首要问题是网络间进程标识问题
                -->以及多重协议的识别问题
        ----随着UNIX操作系统的广泛应用，Socket成为最流行的网络通信应用程序的开发接口
    2.Socket编程编程(TCP)
        1)热身
            (Ⅰ)字节序
                ----Socket是BSD提供的网络应用编程接口,现在它已经是网络编程中的标准
                ----Socket是一种特殊的进程间通信方式,不同机器上的进程都可以使用这种方式进行通信
                    --->网络中的数据传输是一种I/O操作
                    --->read、write、close操作可应用于Socket描述符
                    --->Socket是一种文件描述符,代表了一个通信管道的一个端点
                    --->在Socket类型的文件描述符上,可以完成建立连接,数据传输等操作
                    --->常用的Socket类型有两种
                        -->1.流式Socket:SOCK_STREAM,提供面向连接的Socket
                        -->2.数据报式Socket:SOCK_DGRAM,提供面向无连接的Socket
                ----概念
                    --->是指多字节数据的存储顺序
                ----分类
                    --->小端格式:将低位字节数据存储在低地址
                    --->大端格式:将高位字节数据存储在低地址
                    --->"E:\学习笔记\其他资料\Linux\Image\大端、小端存储.jpg"
                ----特点
                    --->网络协议指定了通讯字节序--大端
                    --->只有在多字节数据处理时才需要考虑字节序
                    --->运行在同一台计算机上的进程相互通信时,一般不用考虑字节序
                    --->异构计算机之间通讯，需要转换自己的字节序为网络字节序
                ----确定主机字节序程序
                    ||
                    ||  #include <stdio.h>
                    ||  int main(int argc,char *argv[])
                    ||  {
                    ||      union{
                    ||          short s;
                    ||          char c[sizeof(short)];
                    ||      }un;
                    ||      un.s = 0x0102;
                    ||      if((un.c[0] == 1) && (un.c[1] == 2))
                    ||      {
                    ||          printf("这是大端存储\n");
                    ||      }
                    ||      else if((un.c[0] == 2) && (un.c[1] == 1))
                    ||      {
                    ||          printf("这是小端存储\n");
                    ||      }
                    ||      return 0;
                    ||  }
                    ||
                ----字节序转换函数
                    ---->主机字节序数据转换成网络字节序数据
                        ||  uint32_t htonl(uint32_t hostint32);
                        ||  uint16_t htons(uint16_t hostint16);
                        ----以上返回网络字节序数据
                    --->网络字节序数据转换成主机字节序数据
                        ||  uint32_t ntohl(uint32_t netint32);
                        ||  uint16_t ntohs(uint16_t netint16);
                        ----以上返回主机字节序数据
                    --->将32位主机字节序数据转换成网络字节序数据
                        ||  #include <arpa/inet.h>
                        ||  uint32_t htonl(uint32_t hostint32);
                        ----功能
                            --->将32位主机字节序数据转换成网络字节序数据
                        ----参数
                            --->uint32_t: unsigned int
                            --->hostint32:待转换的32位主机字节序数据
                        ----返回值
                            --->成功:返回网络字节序的值
                    --->将16位主机字节序数据转换成网络字节序数据
                        ||  #include <arpa/inet.h>
                        ||  uint16_t htons(uint16_t hostint16);
                        ----功能
                            --->将16位主机字节序数据转换成网络字节序数据
                        ----参数
                            --->uint16_t: unsigned short int
                            --->hostint16: 待转换的16位主机字节序数据
                        ----返回值
                            --->成功:返回网络字节序的值
                    --->将32位网络字节序数据转换成主机字节序数据
                        ||  #include <arpa/inet.h>
                        ||  uint32_t ntohl(uint32_t netint32);
                        ----功能
                            --->将32位网络字节序数据转换成主机字节序数据
                        ----参数
                            --->uint32_t: unsigned int
                            --->netint32: 待转换的32位网络字节序数据
                        ----返回值
                            --->成功:返回主机字节序的值
                    --->将16位网络字节序数据转换成主机字节序数据
                        ||  #include <arpa/inet.h>
                        ||  uint16_t ntohs(uint16_t netint16);
                        ----功能
                            --->将16位网络字节序数据转换成主机字节序数据
                        ----参数
                            --->uint16_t: unsigned short int
                            --->netint16: 待转换的16位网络字节序数据
                        ----返回值
                            --->成功:返回主机字节序的值
                    --->"E:\学习笔记\其他资料\Linux\Image\字节序示例.jpg"
            (Ⅱ)套接字地址结构
                ----sockaddr_in套接字地址结构
                    --->在IPv4因特网域(AF_INET)中,套接字地址结构用sockaddr_in命名
                        ||
                        ||  #include <netinet/in.h>
                        ||
                        ||
                        ||  struct in_addr
                        ||  {
                        ||      in_addr_t s_addr;
                        ||      //4字节
                        ||  };
                        ||  struct sockaddr_in
                        ||  {
                        ||      sa_family_t sin_family;    //2字节
                        ||      in_port_t sin_port;        //2字节
                        ||      struct in_addr sin_addr;   //4字节
                        ||      unsigned char sin_zero[8]; //8字节
                        ||  };
                        ||
                ----sockaddr通用套接字地址结构
                    --->地址标识了特定通信域中的套接字端点,地址格式与特定通信域相关,为了使不同格式地址能被传入套接字函数,地址被强制转换成"通用套接字地址结构"
                        ||  
                        ||  #include <netinet/in.h>
                        ||  
                        ||  
                        ||  
                        ||  struct sockaddr
                        ||  {
                        ||      sa_family_t sa_family; //2字节char
                        ||      sa_data[14];           //14字节
                        ||  };
                        ||  
            (Ⅲ)地址转换函数
                ----将点分十进制数串转换成32位无符号整数
                    ||  #include <arpa/inet.h>
                    ||  int inet_pton(int family, const char*strptr, void *addrptr);
                    ----功能
                        --->将点分十进制数串转换成32位无符号整数
                    ----参数
                        --->family  协议族
                        --->strptr  点分十进制数串
                        --->addrptr 32 位无符号整数的地址
                    ----返回值
                        --->成功:1
                        --->失败:其它
                ----将32位无符号整数转换成点分十进制数串
                    ||
                    ||  #include <arpa/inet.h>
                    ||
                    ||  //len的宏定义
                    ||  #define INET_ADDRSTRLEN   16
                    ||  #define INET6_ADDRSTRLEN  46  //for ipv6
                    ||  const char *inet_ntop(int family, constvoid *addrptr, char *strptr, size_t len); 
                    ----功能
                        --->将32位无符号整数转换成点分十进制数串
                    ----参数
                        --->family  协议族
                        --->addrptr 32 位无符号整数
                        --->strptr  点分十进制数串
                        --->len     strptr缓存区长度
                    ----返回值
                        --->成功:则返回字符串的首地址
                        --->失败:返回NULL
            (Ⅳ)服务模型
                ----"E:\学习笔记\其他资料\Linux\Image\socket服务模型.png"
        2)创建套接字
            ----创建套接字是进行任何网络通信时必须做的第一步
            ----创建一个用于网络通信的I/O描述符(套接字)
                ||  #include <sys/socket.h>
                ||  int socket(int family, int type，int protocol);
                ----功能
                    --->创建一个用于网络通信的I/O描述符(套接字)
                ----参数
                    --->family:协议族
                        --> AF_INET，AF_INET6，AF_LOCAL，AF_ROUTE，AF_KEY
                    --->type:套接字类型
                        --> SOCK_STREAM，SOCK_DGRAM，SOCK_RAW,SOCK_SEQPACKET
                    --->protocol:协议类别
                        -->0，IPPROTO_TCP，IPPROTO_UDP，IPPROTO_SCTP25
                ----返回值
                    --->套接字
                ----socket创建的套接字特点
                    --->使用socket创建套接字时，系统不会分配端口
                    --->使用socket创建的是主动套接字，但作为服务器，需要被动等待别人的连接
                ----Socket示例:创建TCP套接字
                    ||
                    ||  //创建TCP套接字
                    ||  int sockfd = 0;
                    ||  sockfd = socket(AF_INET,SOCK_STREAM,0);
                    ||  if(sockfd < 0)
                    ||  {
                    ||      perror("socket");
                    ||      exit(-1);
                    ||  }
                    ||  
        3)服务器
            ----做为服务器需要具备的条件
                --->具备一个可以确知的地址，以便让别人找到我
                --->让操作系统知道你是一个服务器，而不是一个客户端
                --->等待连接的到来
            ----对于面向连接的TCP协议来说，连接的建立才真正意味着数据通信的开始
            ----将本地协议地址与sockfd绑定
                ||  #include <sys/socket.h>
                ||  int bind(int sockfd,const struct sockaddr *myaddr，socklen_t addrlen);
                ----功能
                    --->将本地协议地址与sockfd绑定
                ----参数
                    --->sockfd  socket套接字
                    --->myaddr  指向特定于协议的地址结构指针
                    --->addrlen 该地址结构的长度
                ----返回值
                    --->成功:返回0
                    --->失败:其他
                ----bind示例:
                    ||
                    ||    int err_log = 0;
                    ||    struct sockaddr_in my_addr;
                    ||    unsigned short port = 8000;
                    ||
                    ||    bzero(&my_addr,sizeof(my_addr));
                    ||    my_addr.sin_family = AF_INET;
                    ||    my_addr.sin_port = htons(port);
                    ||    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);
                    ||
                    ||    err_log = bind(sockfd,(struct sockaddr *)&my_addr,sizeof(my_addr));
                    ||    if(err_log != 0)
                    ||    {
                    ||        perror("binding");
                    ||        close(sockfd);
                    ||        exit(-1);
                    ||    }
                    ||
                    ----注意:INADDR_ANY 通配地址,值为0
            ----将套接字由主动修改为被动
                ||  #include <sys/socket.h>
                ||  int listen(int sockfd, int backlog);
                ----功能
                    --->将套接字由主动修改为被动
                    --->使操作系统为该套接字设置一个连接队列，用来记录所有连接到该套接字的连接
                ----参数
                    --->sockfd  socket监听套接字
                    --->backlog 连接队列的长度
                ----返回值
                    --->成功:返回0
                    --->失败:其他
                ----listen示例
                    ||
                    ||    err_log = listen(sockfd,10);
                    ||    if(err_log != 0)
                    ||    {
                    ||        perror("listen");
                    ||        close(sockfd);
                    ||        exit(-1);
                    ||    }
                    ||
            ----从已连接队列中取出一个已经建立的连接，如果没有任何连接可用，则进入睡眠等待
                ||  #include <sys/socket.h>
                ||  int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);
                ----功能
                    --->从已连接队列中取出一个已经建立的连接，如果没有任何连接可用，则进入睡眠等待
                ----参数
                    --->sockfd  socket监听套接字
                    --->cliaddr 用于存放客户端套接字地址结构
                    --->addrlen 套接字地址结构体长度
                ----返回值
                    --->已连接套接字
                ----注意
                    --->accept函数返回的是一个已连接套接字，这个套接字代表当前这个连接
                ----accept示例
                    ||
                    ||    struct  sockaddr_in client_addr;
                    ||    char recv_buf[512] = "";
                    ||    char cli_ip[INET_ADDRSTRLEN] = "";
                    ||    socklen_t client_addr_len = sizeof(client_addr);
                    ||
                    ||    int connfd = accept(sockfd,(struct sockaddr*)&client_addr,&client_addr_len);
                    ||    if(connfd < 0)
                    ||    {
                    ||        perror("accept");
                    ||        close(sockfd);
                    ||        exit(-1);
                    ||    }
                    ||    
                    ||    inet_ntop(AF_INET,&client_addr.sin_addr,cli_ip,INET_ADDRSTRLEN);
                    ||    printf("cli_ip:%s,port = %d\n",cli_ip,ntphs(client_addr.sin_port));
                    ||
                    ||    read(connfd,recv_buf,sizeof(recv_buf));
                    ||
                    演示echo服务器35大纲 概述 Socket编程编程(TCP)热身创建套接字服务器客户端数据传输关闭连接36客户端 作为客户端需要具备的条件知道服务器的IP地址以及端口号37客户端 int connect(int sockfd,const structsockaddr *addr,socklen_t len); 功能:主动跟服务器建立链接连接建立成功后才可以开始传输数据(对于TCP协议) 参数:sockfd:socket套接字addr: 需连接的服务器地址结构addrlen:地址结构体长度38客户端 返回值:成功:0失败:其他 注意:connect函数建立连接之后不会产生新的套接字 头文件:#include <sys/socket.h>39 connect示例:客户端40客户端 connect示例:练习echo客户端41大纲 概述 Socket编程编程(TCP)热身创建套接字服务器客户端数据传输关闭连接42数据传输 当连接建立后，通信的两端便具备两个套接字套接字也是一种文件描述符，所以read、write函数可以用于从这个连接中取出或向其写入数据43数据传输 ssize_t send(int sockfd, const void* buf,size_t nbytes, int flags); 功能:用于发送数据注意:不能用TCP协议发送0长度的数据包 参数:sockfd: socket套接字buf:   待发送数据缓存区的地址nbytes: 发送缓存区大小(以字节为单位)flags:  套接字标志(常为0) 返回值:成功发送的字节数 头文件:#include <sys/socket.h>44数据传输 ssize_t recv(int sockfd, void *buf,size_tnbytes, int flags); 功能:用于接收网络数据 参数:sockfd: 套接字buf:            指向接收网络数据的缓冲区nbytes:         接收缓冲区的大小(以字节为单位)flags:          套接字标志(常为0) 返回值:成功接收到字节数 头文件:#include <sys/socket.h>45大纲 概述 Socket编程编程(TCP)热身创建套接字服务器客户端数据传输关闭连接46关闭连接使用close函数即可关闭套接字•关闭一个代表已连接套接字将导致另一端接收到一个0长度的数据包•做服务器时关闭socket创建的监听套接字将导致服务器无法继续接受新的连接，但不会影响已经建立的连接关闭accept返回的已连接套接字将导致它所代表的连接被关闭，但不会影响服务器的监听•做客户端时关闭连接就是关闭连接，不意味着其他47Socket编程——总结 面向连接的服务模型TCP服务器socket()bind()listen()TCP客户端socket()accept()connect()连接建立(TCP三次握手)一直阻塞到客户连接到达write()数据(请求)read()处理请求read()数据(应答)write()close()文件结束通知close()48Socket编程——总结 TCP面向连接的三次握手过程49Socket编程——总结 TCP面向连接的四次挥手过程close( 主动关闭)(被动关闭)read返回0close演示TCP聊天程序50UDP网络编程2大纲 概述 基本UDP编程 UDP广播3大纲 概述 基本UDP编程 UDP广播4概述 UDP协议UDP是面向无连接的用户数据报协议，在传输数前不需要先建立连接。目地主机的运输层收到UDP报文后，不需要给出任何确认 UDP协议与TCP协议的差异5概述 如何在TCP和UDP之间取舍广播和多播应用必须使用UDP简单的请求-应答应用程序可以使用UDP对于海量数据传输不应该使用UDP UDP的使用场合DNS、NFS、流媒体传输等等6大纲 概述 基本UDP编程 UDP广播7基本UDP编程 典型的UDP客户/服务器程序8基本UDP编程 ssize_t recvfrom(int sockfd, void *buf,size_t nbytes,int flags,structsockaddr *from, socklen_t *addrlen); 功能:用于接收数据 参数:sockfd:套接字buf:    接收数据缓冲区nbytes:接收数据缓冲区的大小flags:  套接字标志(常为0)from:   用于存放发送方信息的地址结构体指针addrlen: from所指内容的长度9 注意:基本UDP编程struct sockaddr *from, socklen_t *addrlen类似于accept函数的最后两个参数通过from和addrlen参数存放数据来源可以为NULL, 表示不关心数据来源 返回值:成功:接收到的字符数失败: -110基本UDP编程 ssize_t sendto(int sockfd，const void*buf, size_t nbytes,int flags, conststruct   sockaddr *to,socklen_t addrlen); 功能:用于发送数据 参数:sockfd:套接字buf:发送数据缓冲区nbytes:发送数据缓冲区的大小flags:一般为0to:指向目的主机地址结构体的指针addrlen:to所指向内容的长度11 注意:基本UDP编程const struct sockaddr *to,socklen_t addrlen类似于connect函数的最后两个参数通过to和addrlen确定目的地址发送一个0长度的UDP数据包是可行的 返回值:成功:发送的字符数失败: -112 UDP Echo Server基本UDP编程13 UDP Echo Server基本UDP编程14 UDP Echo Server基本UDP编程15基本UDP编程 UDP ClientUDP客户端socket()sendto()recvfrom()close()16基本UDP编程 UDP ClientUDP客户端socket()sendto()recvfrom()close()练习客户端和服务器17大纲 概述 基本UDP编程 UDP广播37 UDP广播概述UDP广播广播:由一台主机向该主机所在子网内的所有主机发送数据的方式广播只能用UDP或原始IP实现，不能用TCP广播的用途单个服务器与多个客户主机通信时减少分组流通地址解析协议(ARP)动态主机配置协议(DHCP)网络时间协议(NTP)38UDP广播广播地址•{子网ID，主机ID}子网ID表示由子网掩码中1覆盖的连续位主机ID表示由子网掩码中0覆盖的连续位•子网定向广播地址:主机ID全1例如:对于192.168.220.0/24子网，192.168.220.255即为其定向广播地址通常路由器不转发该广播•受限广播地址:255.255.255.255路由器从不转发该广播通常在DHCP等应用中把该地址当做宿主地址，因为此时客户主机还不知道所处子网的信息39UDP广播UDP广播的特点处于同一子网的所有主机都必须处理数据UDP数据包会沿协议栈向上一直到UDP层运行音视频等较高速率工作的应用，会带来大负局限于局域网内使用41 套接口选项UDP广播int setsockopt(int sockfd, int level,int optname,const void *optval, socklen_t optlen);成功执行返回0，否则返回-1levelSOL_SOCKEToptnameSO_BROADCASTSO_RCVBUFSO_SNDBUF说明允许发送广播数据包接收缓冲区大小发送缓冲区大小optval类型intintint42 广播示例:UDP广播43 广播示例UDP广播44
        4)客户端
        5)数据传输
        6)关闭连接



1)
            ----
                --->
                    -->
                ->
[[⭐]]



                ----功能
                    --->
                ----参数
                    --->
                        -->
                ----返回值
                    --->


    

----
1)
    ----
        --->
            -->
                ->
1)
2)
3)
4)
5)
6)
7)
8)
9)
10)
||
//
##

Ⅰ)
Ⅱ)
Ⅲ)
Ⅳ)
Ⅴ)
Ⅶ)
Ⅷ)
Ⅸ)
Ⅹ)