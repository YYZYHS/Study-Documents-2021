现在安排：
1、我们现在还有2个项目要做，把这个两个项目做完就OK了；
   这两个项目需要硬件支撑的（stm32开发板和tiny4412开发板）
   这两个项目就是以分组的形式进行的；

2、你们经过过年这段时间，你们未来考虑好了没？
   你们过年这段时间在家里学习过没有?
   你们过年在家开心吗？

3、后面重点工作：1、我们两个项目；2、毕业设计；3、找工作

4、下面的安排就是：
	1）每天汇报下你们学习的状况
        2）每天刷题，开始投简历（找工作的一批学生）
        3）投简历之前必须要把你的简历发给我看看（我审核一下）
	4）投简历的时候，最好做个记录，你投了什么公司，什么岗位？

=========================================================================
5、总结一下第一个实训的情况：
	1）第一个实训的情况很糟糕，大部分同学都没有达到要求；
	2）第一个实训，大部分同学给我的感觉是你们还在上大一；
        3）第一个实训，一部分同学是抄都不会抄的；
        4）也有好的学生，自己做的同学（分数给的相对比较高些）；

6、下面两个项目要求：
	1）分组进行的，组内的成员最起码要知道代码怎么运行，项目框架逻辑之类的
        2）积极去问问题，去解决问题；

7、关于下周过来的问题：
	1）我接到的通知是必须要过来；我可以盯着你去学习


春节期间，在家里学习过的同学，在群里call个3
春节期间，未来的路考虑好了没有？


英文阅读能力要OK的   沟通？两码事
==================================================================
智能家居系统   比较简单智能家居系统

使用TINY4412开发板   ->  这个开发板就是ARM板子

ARM是什么东西？ 表示是一家公司、也比较是一个技术

RISC：精简指令集 （ARM）
CISC：复杂指令集 （X86）

=================================================================
ARM指令 和 Thumb指令

ARM处理器共有7种运行模式：用户模块、快速中断模式、外部中断模式、特权模式、数据访问中止模式、未定义指令模式、系统模式

ARM寄存器：总共有37个寄存器，其中31个是通用寄存器、6个是状态寄存器
======================================
ARM指令集可以分为跳转指令、数据处理指令、程序状态寄存器(PSR)传输指令、Load/Store指令、协处理器指令和异常中断产生指令6类。

=======================================================
ARM指令的寻址方式：
1）数据处理指令的操作数的寻址方式
2）字及无符号字节的Load/Store指令的寻址方式
3）杂类Load/Store指令的寻址方式
4）批量Load/Store指令的寻址方式
5）协处理器Load/Store指令的寻址方式

ARM指令集可以分为6类，即跳转指令、数据处理指令、程序状态寄存器(PSR)传输指令、Load/Store指令、协处理器指令和异常中断产生指令。

跳转指令：跟我们以往学习比较熟悉是什么？goto语句


非T系列的ARM指的是不包含Thumb指令的

数据处理指令包括以下指令：
MOV：数据传送指令；
MVN：数据求反传送指令；
CMP：比较指令；
CMN：基于相反数的比较指令；
TST：位测试指令；
TEQ：相等测试指令；
ADD：加法指令；
SUB：减法指令；
RSB：逆向减法指令；
ADC：带位加法指令；
SBC：带位减法指令；
RSC：带位逆向减法指令；
AND：逻辑与操作指令；
BIC：位清除指令；
EOR：逻辑异或操作指令；
ORR：逻辑或操作指令。

Load指令用于从内存中读取数据放入寄存器中；Store指令用于将寄存器中的数据保存到内存。
通俗的理解：就是从内存中读数据到CPU中，把CPU中数据保存到内存中。

=============================================================
ARM协处理器指令包括以下3类：
1）用于ARM处理器初始化ARM协处理器的数据处理操作；
2）用于ARM处理器的寄存器和ARM协处理器的寄存器间的数据传送操作；
3）用于在ARM协处理器的寄存器和内存单元之间传送数据。
===============================================================
盐城工学院的小伙伴们：你们的毕设材料啥时候给我？？？
================================================================
指令集的一些就相当于学习一个新的语言（汇编语言）

伪操作不像机器指令那样在计算机运行期间由机器执行，它是在汇编程序对源程序汇编期间由汇编程序处理的。

==================================
GBLS STR1                声明一个全局变量STR1
GBLS STR2		 声明一个全局变量STR2
STR1 SETS "pen"			给STR1赋值"pen"
STR2 SETS "this is a $STR1"

汇编程序中以";"开头作为注释用的 就相当于C语言里的/* */ 或者 //
==================================================================
项目《基于TINY4412智能家居系统的设计与实现》
项目的知识点:C/C++知识点，socket编程、多线程会涉及到，ARM一些知识点，内核这块
项目的环境：PC下的QT，Tiny4412开发板的
项目的功能：点亮LED灯、获取温度（温湿度传感器DHT11?）、蜂鸣器报警。。。
	    可以在PC机程序上控制板子的灯、温湿度等。。
     	    也可以在板子的程序上直接控制！
==================================================================
项目怎么做？
1、嵌入式方向一个项目怎么来实现？
2、开发环境的搭建，是你做项目的前提条件之一，且非常的重要！
3、要有个主机和目标机的概念区分（分清）。
	你是在主机（PC）里搭建开发环境，程序是运行在目标机（开发板）里的。
	主机上编写目标机上的运行程序。
4、要知道测试程序，主机上编写OK之后要把程序放到目标机上进行运行验证。
====================================================================
第一个重要的环节：开发环境的搭建！~

在Ubuntu系统上搭建可以在板子上运行的Qt程序。

交叉编译？ 

一般情况下，linux下编程的话，是不是直接gcc  hello.c  生成a.out   直接运行
这边运行是在PC机上运行的，PC（windows），CPU是X86架构的

需要在板子上运行程序，一般来说开发板都是ARM开发板，所以CPU是ARM架构的

而X86架构的程序是不能再ARM架构板子上运行的。

所以想要让程序能够在ARM板子上运行的话，或者修改其编译器，让这个编译器编译生成的可执行文件能够在ARM板子上运行。

X86是采用的gcc/g++，进行交叉编译环境的搭建，在linux中安装交叉编译工具，通过交叉编译工具生成的可执行文件，能够在板子上运行。
=====【专业的】
谓交叉编译就是在一个平台上生成另一个平台上能够运行的代码。平台包含体系结构和操作系统两个部分，为了在PC上编译出ARM+Linux平台上能够运行的代码，需要在主机平台上安装对应的交叉编译工具链（cross compile-action tool chain）,编译源代码生成可在目标平台上运行的代码。

================================================================
tar zxvf arm-linux-gcc-4.5.1-v6-vfp-20101103.tgz -C /
【解释】  -C 表示是指定压缩后的文件存放的位置
          /  表示是 根目录

对根目录（/）的一些操作，必须是root权限才能操作，不然就会失败


环境变量设置  .bashrc里面进行操作
export PATH=$PATH:/opt/FriendlyARM/toolschain/4.5.1/bin

==========================================================
qst@qst:~$ gcc hello.c 		    //正常的操作
qst@qst:~$ file a.out 
a.out: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=77f8cbe2798b81b8fd29369fa2208341e9dc1802, not stripped
qst@qst:~$ arm-linux-gcc hello.c    //交叉编译
qst@qst:~$ file a.out 
a.out: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.27, not stripped




























                  